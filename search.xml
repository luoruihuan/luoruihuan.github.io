<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Puppeteer 入门]]></title>
    <url>%2Fposts%2Fpuppeteer%2F</url>
    <content type="text"><![CDATA[一、Puppeteer 是什么Puppeteer，翻译成中文可以理解成傀儡的意思，他是一个Node库，主要是提供接口来控制 headless chrome ，也就是无头浏览器，无头浏览器是一种不使用chrome来运行chrome浏览器的方式，简单来讲，其实就是编写javascript 代码自动化控制 Chrome。 我们能用Puppeteer做些什么 1、利用网页生成PDF，图片 2、主要的从网站抓取内容。 3、自动化表单提交、UI测试、键盘输入等。 4、捕获站点的时间线，一遍追踪网站，帮助分析网站性能问题。 二、运行环境Node 版本大于 V7.6.0，因为Puppeteer中所有的操作几乎都是一步的，如果使用大量的then会使代码的可读性特别低，所以选择ES7中的 async，await 语法，这也是 Puppeteer 官方推荐的写法。 三、基本用法1、入门 Demo 屏幕截图12345678910111213141516const puppeteer = require('puppeteer');async function getPic() &#123; // 启动 puppeteer const browser = await puppeteer.launch(&#123; headless: false &#125;); // 在浏览器中创建一个新的页面 const page = await browser.newPage(); // 使用 goto 打开指定网页 await page.goto("https://www.baidu.com"); // 调整页面配置大小，截图更好看 await page.setViewport(&#123; width: 1400, height: 900 &#125;); // 使用 screenshot 函数对网页进行截屏 await page.screenshot(&#123; path: 'baidu.png' &#125;) // 关闭浏览器 await browser.close();&#125;getPic(); 2、基础使用属性① puppeteer.launch(options) options 参数详解 参数名称 参数类型 参数说明 ignoreHTTPSErrors boolean 在请求的过程中是否忽略 Https 报错信息，默认为 false headless boolean 是否以”无头”的模式运行 chrome, 也就是不显示 UI， 默认为 true executablePath string 可执行文件的路劲，Puppeteer 默认是使用它自带的 chrome webdriver, 如果你想指定一个自己的 webdriver 路径，可以通过这个参数设置 slowMo number 使 Puppeteer 操作减速，单位是毫秒。如果你想看看 Puppeteer 的整个工作过程，这个参数将非常有用。 args Array(String) 传递给 chrome 实例的其他参数，比如你可以使用”–ash-host-window-bounds=1024x768” 来设置浏览器窗口大小。 handleSIGINT boolean 是否允许通过进程信号控制 chrome 进程，也就是说是否可以使用 CTRL+C 关闭并退出浏览器. timeout number 等待 Chrome 实例启动的最长时间。默认为30000（30秒）。如果传入 0 的话则不限制时间 userDataDir string 设置用户数据目录，默认linux 是在 ~/.config 目录，window 默认在 C:\Users{USER}\AppData\Local\Google\Chrome\User Data, 其中 {USER} 代表当前登录的用户名. env Object 指定对Chromium可见的环境变量。默认为process.env. devtools boolean 是否为每个选项卡自动打开DevTools面板， 这个选项只有当 headless 设置为 false 的时候有效 ② Browser 对象当 Puppeteer 连接到一个 Chrome 实例的时候就会创建一个 Browser 对象，有以下两种方式：Puppeteer.launch 和 Puppeteer.connect. Browser 对象 API : 方法名称 返回值 说明 browser.close() Promise 关闭浏览器 browser.disconnect() void 断开浏览器连接 browser.newPage() Promise(Page) 创建一个 Page 实例 browser.pages() Promise(Array(Page)) 获取所有打开的 Page 实例 browser.targets() Array(Target) 获取所有活动的 targets browser.version() Promise(Page) 获取浏览器的版本 browser.wsEndpoint() String 返回浏览器实例的 socket 连接 URL, 可以通过这个 URL 重连接 chrome 实例 Puppeteer 详细Api地址 https://github.com/puppeteer/puppeteer/blob/main/docs/api.md 四、实战获取京东商城手机商品首先梳理操作流程： ①、打开京东首页 ②、输入手机关键字并搜索 ③、获取前10个商品的A标签，并获取商品详情链接。 ④、分别打开10个详情图，截取网页图片。 要实现上面的功能，需要用到查找元素，获取属性，键盘回车等，接下来一个一个讲解一下。 1、获取元素Page 对象提供了2个API来获取页面元素：(1). Page.$(selector) 获取单个元素，底层是调用的是 document.querySelector() , 所以选择器的 selector 格式遵循 css 选择器规范; 1let inputElement = await page.$('#search'); (2). Page.$$(selector) 获取一组元素，底层调用的是 document.querySelectorAll(). 返回 Promise(Array(ElemetHandle)) 元素数组.1const links = await page.$$("a"); 2、获取元素属性(1). Page.$eval(selector, pageFunction[, …args]), 获取单个元素的属性123const value = await page.$eval('input[name=search]', input =&gt; input.value);const href = await page.$eval('#a", ele =&gt; ele.href);const content = await page.$eval('.content', ele =&gt; ele.outerHTML); (2). Page.$$eval(selector, pageFunction[, …args]), 获取元素数组的属性 3、键盘和鼠标事件键盘和鼠标的API比较简单，键盘的几个API如下： keyboard.down(key[, options]) 触发 keydown 事件 keyboard.press(key[, options]) 按下某个键，key 表示键的名称 keyboard.sendCharacter(char) 输入一个字符 keyboard.type(text, options) 输入一个字符串 keyboard.up(key) 触发 keyup 事件 page.keyboard.press(“Shift”); //按下 Shift 键 page.keyboard.sendCharacter(‘嗨’); page.keyboard.type(‘Hello’); // 一次输入完成 page.keyboard.type(‘World’, {delay: 100}); // 像用户一样慢慢输入 鼠标Api如下: mouse.click(x, y, [options]) 移动鼠标指针到指定的位置，然后按下鼠标，这个其实 mouse.move 和 mouse.down 或 mouse.up 的快捷操作 mouse.down([options]) 触发 mousedown 事件，options 可配置: options.button 按下了哪个键，可选值为[left, right, middle], 默认是 left, 表示鼠标左键 options.clickCount 按下的次数，单击，双击或者其他次数 delay 按键延时时间 mouse.move(x, y, [options]) 移动鼠标到指定位置， options.steps 表示移动的步长 mouse.up([options]) 触发 mouseup 事件 4、其他实用APIpage.waitForSelector(selector[, options]) 等待某个选择器的元素加载之后，这个元素可以是异步加载的，这个 API 非常有用，比如我想获取某个通过 js 异步加载的元素，那么直接获取肯定是获取不到的。这个时候就可以使用 page.waitForSelector 来解决。 5、实现代码12345678910111213141516171819202122232425262728293031323334353637383940const puppeteer = require('puppeteer');const fs = require('fs');const path = require('path');async function getShopDetail() &#123; // 启动 puppeteer const browser = await puppeteer.launch(&#123; headless: false, ignoreHTTPSErrors: true &#125;); let page = await browser.newPage(); // 启用Javascript,允许执行js脚本 await page.setJavaScriptEnabled(true); // 打开京东网页 await page.goto("https://www.jd.com/"); // 获取搜索框元素 const searchInput = await page.$("#key"); // 定位到搜索框 await searchInput.focus(); // 输入搜索内容 await page.keyboard.type("手机"); // 获取搜索按钮 const searchBtn = await page.$(".button"); // 执行点击事件 await searchBtn.click(); // 等待元素加载之后，否则获取不异步加载的元素 await page.waitForSelector('.gl-item'); // 获取搜索结果 const links = await page.$$eval('.gl-item &gt; .gl-i-wrap &gt; .p-img &gt; a', links =&gt; &#123; return links.map(a =&gt; &#123; return &#123; href: a.href.trim(), title: a.title &#125; &#125;); &#125;); const content = JSON.stringify(links); const file = path.join(__dirname, 'resource/index.json'); fs.writeFile(file, content, ()=&gt; &#123;&#125;); await browser.close();&#125;getShopDetail(); 五、定制属于自己的个人资讯网站 抓取资讯 puppeteer 定时任务 node-schedule 部署 docker + github pages 主要思路: puppeteer 定时抓取各个网站板块信息，每次获取内容后，保存至数据库或者简单的用Json保存，保存完成，只需要请求这个文件就可以渲染出需要的内容，定时任务可以用过 node-schedule 库来实现，部署可以采用 docker + gittpage 部署。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解输入url到页面加载，为了更好地性能优化]]></title>
    <url>%2Fposts%2FwebOptimize%2F</url>
    <content type="text"><![CDATA[一、 DNS解析过程DNS 全称 DomainName System 域名系统，俗称电话本。DNS解析就是通过域名最终得到对应ip地址，知道哪台服务器上有你需要的资源的过程。当然如何进行DNS 解析又是另外的话题。 1、首先搜索浏览器自身的DNS缓存，有缓存直接返回;2、浏览器自身DNS不存在，浏览器就会调用一个类似 gethostbyname 的库函数,此函数会先去检测本地hosts文件，查看是否有对应ip。3、如果本地hosts文件不存在映射关系，就会查询路由缓存，路由缓存不存在就去查找本地DNS服务器（一般TCP/IP参数里会设置首选DNS服务器，通常是8.8.8.8);4、如果本地DNS服务器还没找到就会向根服务器发出请求。具体过程： 本地DNS服务器代我们的浏览器发起迭代DNS解析请求，首先它会找根域的DNS的IP地址（全球13台哟，可惜中国没有！）。找到根域的DNS地址,就会向其发起请求； 根域发现这是一个顶级域top域的一个域名，于是告诉本地DNS服务器我不知道这个域名的IP地址,但是我知道top域的IP地址，你去找它去吧； 于是本地DNS服务器就得到了top域的IP地址，又向top域的IP地址发起了请求（请问www.luoruihuan.top这个域名的IP地址是多少呀?）,于是top域服务器告诉本地DNS服务器我不知道www.luoruihuan.top这个域名的IP地址，但是我知道luoruihuan.top这个域的DNS地址，你去找它去; 于是本地DNS服务器又向luoruihuan.top这个域名的DNS地址（这个一般就是由域名注册商提供的，像万网，新网等）发起请求（请问www.luoruihuan.top这个域名的IP地址是多少？），这个时候luoruihuan.top域的DNS服务器一查，呀！果真在我这耶，于是就把找到的结果发送给本地DNS服务器; 这个时候本地DNS服务器就拿到了www.luoruihuan.top这个域名对应的IP地址。 从上述过程中，可以看出网址的解析是一个从右向左的过程: top -&gt;luoruihuan.top -&gt; www.luoruihuan.top。但是你是否发现少了点什么，根域名服务器的解析过程呢？事实上，真正的网址是www.luoruihuan.top.，并不是我多打了一个.，这个.对应的就是根域名服务器，默认情况下所有的网址的最后一位都是.，既然是默认情况下，为了方便用户，通常都会省略，浏览器在请求DNS的时候会自动加上，所有网址真正的解析过程为: . -&gt; .top -&gt; luoruihuan.top. -&gt; www.luoruihuan.top.。 DNS 缓存，DNS存在着多级缓存，从离浏览器的距离排序的话，有以下几种: 浏览器缓存，系统缓存，路由器缓存，IPS服务器缓存，根域名服务器缓存，顶级域名服务器缓存，主域名服务器缓存。 二、TCP 链接(三次握手)所谓三次握手(Three-way Handshake)，是指建立一个 TCP 连接时，需要客户端和服务器总共发送3个包。 三次握手的目的是连接服务器指定端口，建立 TCP 连接，并同步连接双方的序列号和确认号，交换 TCP 窗口大小信息。 1、客户端发送带有SYN标识（SYN=1，seq=x）的请求报文段，然后进入SYN_SEND状态，等待服务端确认;2、服务端接收到客户端SYN报文段后，需要发送ACK信息对这个SYN进行确认，同时还要发送自己的SYN信息(SYN=1，ACK=1,seq=y，ack=x+1)服务端把这些信息放在一个报文段中((SYN+ACK报文段），一并发给客户端，此时客户端进入SYN_RECV状态;3、客户端接收到服务端的SYN+ACK报文段后会向服务端发送ACK（ACK=1，seq=x+，ack=y+1）确认报文段，这个报文段发送后， 客户端和服务端都进入ESTABLISHED状态，完成三次握手。 为什么会三次握手？这块咋一看会感觉比较复杂，其实这个大家稍微思考一下就能明白，如果两个人需要互相确定可以通讯，步骤其实就是三次，类似于: 浏览器：在吗？服务器：在的浏览器: 好的，我找你是为了诚挚的邀请你，晚上请我吃饭。 这个过程多了或者少了都不能保证确保互相通信，实际信号就是: 浏览器：syn服务器：syn + ack浏览器: ack 三、客户端HTTP请求发送HTTP请求的过程就是: 构建HTTP请求报文并通过TCP协议发送到服务器指定端口(HTTP协议80/8080, HTTPS协议443)。 HTTP请求报文是由三部分组成: 请求行, 请求报头和请求正文。 1234567POST /login HTTP/1.1Host: www.example.comContent-Type: application/x-www-form-urlencodedContent-Length: 30username=hello&amp;password=123456 四、服务端响应HTTP请求HTTP响应也是由 Header 和 Body 两部分组成，响应的第一行总是 HTTP版本 响应代码 响应说明，例如，HTTP/1.1 200 OK 表示版本是 HTTP/1.1 ，响应代码是 200，响应说明是 OK。客户端只依赖响应代码判断HTTP响应是否成功。12345678HTTP/1.1 200 OKContent-Type: text/htmlContent-Length: 133251&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;Hello&lt;/h1&gt; 响应状态码是由3位数组成，第一个数字定义了响应的类别，且有五种可能取值: 1xx：指示信息–表示请求已接收，继续处理。 2xx：成功–表示请求已被成功接收、理解、接受。 3xx：重定向–要完成请求必须进行更进一步的操作。 4xx：客户端错误–请求有语法错误或请求无法实现。例如400表示因为Content-Type等各种原因导致的无效请求，404表示指定的路径不存在； 5xx：服务器端错误–服务器未能实现合法的请求。例如500表示服务器内部故障，503表示服务器暂时无法响应。 当浏览器收到第一个http响应后，解析html后又会发起一系列http请求，例如请求图片，文件等。请求图片时。服务器响应图片请求后，会直接把二进制内容的图片发送给浏览器，因此，服务器总是被动的接收客户端的一个HTTP请求，然后响应他，客户端则根据需要发送若干个HTTP请求。对于最早期的HTTP/1.0协议，每次发送一个HTTP请求，客户端都需要先创建一个新的TCP连接，然后，收到服务器响应后，关闭这个TCP连接。由于建立TCP连接就比较耗时，因此，为了提高效率，HTTP/1.1协议允许在一个TCP连接中反复发送-响应，这样就能大大提高效率，因为HTTP协议是一个请求-响应协议，客户端在发送了一个HTTP请求后，必须等待服务器响应后，才能发送下一个请求，这样一来，如果某个响应太慢，它就会堵住后面的请求。可见，HTTP/2.0进一步提高了效率。 五、TCP链接断开TCP 的连接的拆除需要发送四个包，因此称为四次挥手(Four-way handshake)，。客户端或服务器均可主动发起挥手动作。 1、第一次挥手(FIN=1，seq=x)假设客户端想要关闭连接，客户端发送一个 FIN 标志位置为1的包，表示自己已经没有数据可以发送了，但是仍然可以接受数据。发送完毕后，客户端进入 FIN_WAIT_1 状态。 2、第二次挥手(ACK=1，ACKnum=x+1)服务器端确认客户端的 FIN 包，发送一个确认包，表明自己接受到了客户端关闭连接的请求，但还没有准备好关闭连接。发送完毕后，服务器端进入 CLOSE_WAIT 状态，客户端接收到这个确认包之后，进入 FIN_WAIT_2 状态，等待服务器端关闭连接。 3、第三次挥手(FIN=1，seq=y)服务器端准备好关闭连接时，向客户端发送结束连接请求，FIN 置为1。发送完毕后，服务器端进入 LAST_ACK 状态，等待来自客户端的最后一个ACK。 4、第四次挥手(ACK=1，ACKnum=y+1)客户端接收到来自服务器端的关闭请求，发送一个确认包，并进入 TIME_WAIT状态，等待可能出现的要求重传的 ACK 包。 服务器端接收到这个确认包之后，关闭连接，进入 CLOSED 状态。 客户端等待了某个固定时间（两个最大段生命周期，2MSL，2 Maximum Segment Lifetime）之后，没有收到服务器端的 ACK ，认为服务器端已经正常关闭连接，于是自己也关闭连接，进入 CLOSED 状态。 当然4次挥手主要就是为了保证数据互相完成发送，例如： 1234浏览器：吃饱了，我要走了。服务器：干饭人等一下，我看一下晚上吃饭钱你转给我没有。服务器：钱收到了，那我也走了。浏览器：好的。 当然大家可能想问，其实三次也是可以关闭，为什么非要分四次，这是因为服务端在LISTEN状态下，收到关闭连接的报文时，仅仅表示对方不在发送数据，但是还是可以接受数据的，服务端是否现在关闭数据通道可以理解为上层应用是否还有其他事情要做，因此服务端的ACK和FIN一般都是分开发送。 六、浏览器渲染资源回流导致 reflow 发生的一些原因： 改变窗口大小 改变文字大小 添加删除样式变 内容的改变 激活伪类 操作class属性 脚本操作DOM 计算offsetWidth和offsetHeight 设置style属性 减少 reflow 的一些方法 避免设置大量的style属性，因为设置style每一次都会触发refolw 最好使用class 尽量不使用table布局，因为因为table中某个元素旦触发了reflow，那么整个table的元素都会触发reflow。那么在不得已使用table的场合，可以设置table-layout:auto;或者是table-layout:fixed这样可以让table一行一行的渲染，这种做法也是为了限制reflow的影响范围。 如果css里面有计算表达式，每次都会重新计算一遍，触发一次reflow 七、总结&nbsp;&nbsp;&nbsp;&nbsp;上面主要介绍了一次完整请求对应的过程，了解这个过程的主要目的其实也就是为了web优化，前端的本质一句话可以很好地概括，将用户所需要的信息，快速并友好的展示给用户，并能够与用户进行交互，快速肯定就是尽可能短的时间内完成页面的加载，当然，如何快速的完成页面加载，可以参考雅虎34条军规，这个34条军规实际上就是围绕请求过程进行的一些优化方式。如何尽快的加载资源，大概的一个总体思路，能不从网络中加载的资源就不从网络中加载，这就要我们合理利用缓存，将资源放在浏览器端，这也是最快的方式。如果资源必须从网络中加载，则考虑缩短连接时间，也就是上面提到的DNS优化，类似于DNS 缓存，DNS 负载均衡等，Http方面可以优化响应内容大小，即对内容进行压缩。另一方面，当资源到达浏览器以后，浏览器开始进行解析渲染，浏览器中最耗时的部分就是reflow 回流，围绕这一部分考虑的就是如何减少reflow的次数，reflow 是导致DOM脚本执行效率低的关键因素之一，页面上任何一个节点触发了 reflow，都会导致他的子节点及祖先节点重新渲染，]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>http</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 基础入门知识分享(二)]]></title>
    <url>%2Fposts%2FTypeScript2%2F</url>
    <content type="text"><![CDATA[一、简单介绍&nbsp;&nbsp;&nbsp;&nbsp; 第一篇的时候简单介绍了TS的基本和常用用法，这篇就用webpack搭建一个ts+react的简易demo，react也有官方的脚手架去使用，但是还是感觉自己搭建的脚手架更加可控。 二、搭建开发环境从头搭建一个基于react + ts + webpack + Hooks 的开发环境1234567// 初始化文件夹文件和 package.json$ mkdir React-Typescript-Hooks$ touch webpack.config.js index.html$ npm init -y 打开 webpack.config.js文件，初始化简单的 webpack 配置1234567891011const path = require("path");module.exports = &#123;entry: "./src/index.tsx", output: &#123; path: path.resolve(__dirname, "build"), filename: "bundle.js" &#125;, module: &#123;&#125;, plugins: []&#125;; 然后新增一个入口文件index.tsx123456import * as React from "react";import * as ReactDOM from "react-dom";const ROOT = document.querySelector(".container");ReactDOM.render(&lt;h1&gt;Hello&lt;/h1&gt;, ROOT); 注：for Typescript you have to import all (*) as React.接着需要安装react，webpack依赖模块12345// 注：webpack4.0后，webpack 命令行相关的内容都迁移到 webpack-cli，除了 webpack 外，我们还需要安装 webpack-cli$ npm i react react-dom$ npm i webpack webpack-dev-server webpack-cli -D 我们现在已经有了ts的文件，但是webpack并不能解析，所以需要安装ts解析器 awesome-typescript-loader，为什么不用ts-loader，而选择用 awesome-typescript-loader，你可以点击这里查看。1$ npm i typescript awesome-typescript-loader -D 更新webpack.config，新建对tsx的规则处理12345678 module: &#123; rules: [ &#123; test: /\.tsx?$/, loader: "awesome-typescript-loader" &#125; ]&#125;, 我们还需要在根路径创建一个 tsconfig.json 文件，来告诉 webpack 如何去处理TS的文件12345678910111213141516 &#123; "compilerOptions": &#123; "allowSyntheticDefaultImports": true, "jsx": "react", "module": "commonjs", "outDir": "./build/", "preserveConstEnums": true, "removeComments": true, "sourceMap": true, "noImplicitAny": true, "target": "es5" &#125;, "include": [ "./src/**/*" ]&#125; 接下来我们需要安装react的声明文件，由于 React 和 React-dom 并不是使用 TS 进行开发的，所以 TS 不知道 React、 React-dom 的类型，以及该模块导出了什么，此时需要引入 .d.ts 的声明文件。1$ npm i @types/react @types/react-dom -D 接下来就只要将webpack.config中的test命令更改成下面，就可以直接启动项目了,然后在浏览器中输入localhost:8080 就可以直接查看。1"start": "webpack-dev-server"]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TypeScript 基础入门知识分享(一)]]></title>
    <url>%2Fposts%2FTypeScript%2F</url>
    <content type="text"><![CDATA[一、简单介绍&nbsp;&nbsp;&nbsp;&nbsp;从第一次接触TS到现在其实已经有一年多的时间，当初在上家公司是开始技术栈使用Angular 2，大家都知道Angular2框架是使用TypeScript开发的，Angular和TypeScript一起使用非常简单方便，那时候ES6语法都还比较新，TS可以很好地去补充一些新的属性API，加上那时候后台用的ASP.NET Core，借那个机会也学习了一波，不过最后项目转型使用了vue全家桶，也就放弃了TS的使用，虽然现在vue对ts的支持也已经很好了，现在的工作技术栈集中在React上，所以可以简单的分享下一些TypeScript的用法，和利用webpack+ TypeScript + React Hooks 搭建一个简单的TodoList.这次会分两篇文章，第一篇大致介绍下ts用法，第二篇用webpack搭建一个ts+react的简易demo。 二、TypeScript 概述和基本用法&nbsp;&nbsp;&nbsp;&nbsp;TypeScript本质上是向javaScript语言添加了可选的静态类型和基于类的面向对象编程，同时也支持诸如接口，命名空间，装饰器等特性，相当于js的超集。因为ES6大家都已经很熟悉，所有一些ES6已经包含的语法这边就不在赘述，类似于声明解构赋值，let，const使用，可选参数，默认参数，箭头函数之类的。 1、安装TypeScript相关的工具一般都是通过npm进行安装，安装命令如下：1npm install -g typescript@3.6.0 安装完成后可以来编写第一个TypeScript程序，类似于新建一个hello.ts，加入代码 console.log(&#39;Hello TypeScript!&#39;)，然后通过tsc编译器来编译ts文件，生成相对应的javascript文件，编译代码如下：编译过后的文件可以直接在浏览器中运行1tsc hello.ts 2、基本类型在Ts中，提供了一下基本类型： 布尔类型（boolean） eg : let isDone: boolean = false; 数字类型 (number) eg: let decLiteral: number = 6; 支持二、八、十、十六进制 字符串类型 (string) eg: let name: string = &quot;bob&quot;; 支持模板字符串 数组类型 (array) eg: let list: number[] = [1, 2, 3]; 或者泛型数组，Array&lt;元素类型&gt; 元祖类型 (trup) eg: let x: [string, number]; 表示一个已知元素数量和类型的数组，各元素的类型不必相同 枚举类型（enum） eg : enum Color {Red, Green, Blue} let c: Color = Color.Green; 任意值类型（any） eg : let notSure: any = 4; 一般用于忽略类型检查 空值（void） eg: (): void 一般用于函数没有返回值的情况，像是和any类型相反 Null 和 Undefined 是所有类型的子类型，只有当指定了--strictNullChecks标记，才会严格检查 Never 类型 表示永不存在的值，一般用于抛出错误时使用 3、类&nbsp;&nbsp;&nbsp;&nbsp;ES6中已经支持了基于类的面向对象编程，在Ts中，同样也是使用extends关键字实现继承，封装，继承，多态，是面向对象的三大特性。类必须拥有一个构造函数，如果类扩展了其他类，则创建的任何构造函数都必须要包含对super的调用。这里主要是着重说一下Ts中的类的修饰符。在类中的修饰符可以分为公共(public)、私有(private)、受保护(protected)三种。 &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I、Public 修饰符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在TypeScript里，成员都默认为public。可以自由的访问程序里定义的成员。&nbsp;&nbsp;&nbsp;&nbsp;II、Private 修饰符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;当成员被标记成private时，它就不能在声明它的类的外部访问。&nbsp;&nbsp;&nbsp;&nbsp;III、Protected 修饰符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;protected修饰符与private修饰符的行为很相似，但有一点不同，protected成员在派生类中仍然可以访问。&nbsp;&nbsp;&nbsp;&nbsp;IV、Readonly 修饰符&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;可以使用readonly关键字将属性设置为只读的。 只读属性必须在声明时或构造函数里被初始化。&nbsp;&nbsp;&nbsp;&nbsp;V、静态属性 static&nbsp;&nbsp;&nbsp;&nbsp;到目前为止，我们只讨论了类的实例成员，那些仅当类被实例化的时候才会被初始化的属性。 我们也可以创建类的静态成员，这些属性存在于类本身上面而不是类的实例上。 4、接口&nbsp;&nbsp;&nbsp;&nbsp;Ts的接口使用方式类似于Java，同时还增加了更加灵活的接口类型，包括属性、函数、可索引和类等类型。在TypeScript里，接口的作用就是为类型命名和自己的代码或第三方代码定义契约。在Ts中使用Interface关键字来定义接口。 &nbsp;&nbsp;&nbsp;&nbsp;I、属性接口1234interface FullName &#123; firstName: string; secondName: string;&#125; &nbsp;&nbsp;&nbsp;&nbsp;属性接口的定义很简单，ts还提供了可选属性，可选属性对可能存在的属性进行预定义，并兼容不传值的情况，用法就是在变量名后加一个？写法示例：secondName？: string。&nbsp;&nbsp;&nbsp;&nbsp;II、函数类型接口&nbsp;&nbsp;&nbsp;&nbsp;接口除了描述带有属性的普通对象外，也能描述函数类型，定义函数类型接口时，需要明确定义函数的参数列表，和返回值类型，且参数列表的每个参数都要有参数名和类型，示例：123interface encrypt &#123; （val: string, salt: string）: string&#125; &nbsp;&nbsp;&nbsp;&nbsp;II、可索引类型接口&nbsp;&nbsp;&nbsp;&nbsp;可索引类型接口用来描述那些可以通过索引得到的类型，类似于array[1],object[‘name’]等，其实就是通过特定的索引来得到指定类型的返回值。示例：12345interface indexArray &#123; [index: number]: string&#125;let userArray: indexArray = ['A', 'B'];userArray[0] // 结果为A &nbsp;&nbsp;&nbsp;&nbsp;III、类类型接口&nbsp;&nbsp;&nbsp;&nbsp;类类型接口主要用来规范一个类的内容，示例：123456789101112interface Animal &#123; name: string; setName(n: string): void;&#125;class Dog implements Animal &#123; constructor(n: string) &#123;&#125; name: string; setName(n: string) &#123; this.name = n; &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp;IV、接口拓展&nbsp;&nbsp;&nbsp;&nbsp;和类一样，接口也可以实现相互拓展，即能将成员从一个接口复制到另一个里面，这样可以更灵活的将接口拆分到可复用的模块里，一个接口可以继承多个接口，创建出多个接口的合成接口，示例：1234567891011interface Shape &#123; color: string;&#125;interface Square extends Shape &#123; sideLength: number;&#125;let square = &lt;Square&gt;&#123;&#125;;square.color = "blue";square.sideLength = 10; 5、泛型(generic)&nbsp;&nbsp;&nbsp;&nbsp;在实际开发中，我们定义API不仅仅需要考虑功能是否健全，更多的还要考虑到API的复用性，这个时候急需要组件支持不特定的数据类型，而泛型就是用来实现这样的效果。示例：123function identity&lt;T&gt;(arg: T): T &#123; return arg;&#125; &nbsp;&nbsp;&nbsp;&nbsp;我们给identity方法添加了类型变量T，T帮助我们捕获用户传入的类型，之后我们就可以使用这个类型，例子中就是使用了T作为返回值，这样我们就可以知道参数类型与返回值类型是相同的了。还有就是比较常用的场景就是使用泛型变量，我们改变下之前的例子：1234function identity&lt;T&gt;(arg: T): T &#123; console.log(arg.length); // Error: T doesn't have .length return arg;&#125; &nbsp;&nbsp;&nbsp;&nbsp;如果直接这样使用的话编译器会报错，这是因为并没有地方指明arg具有这个属性，记住，这些类型变量代表的是任意类型，所以使用这个函数的人有可能传入的是个数字，就会报错。所以我们可以假设我们想操作的是T类型的数组，而不直接是T,所以我们可以这样：1234function identity&lt;T&gt;(arg: T[]): T[] &#123; console.log(arg.length); // // Array has a .length, so no more error return arg;&#125; 或者这种写法1234function loggingIdentity&lt;T&gt;(arg: Array&lt;T&gt;): Array&lt;T&gt; &#123; console.log(arg.length); // Array has a .length, so no more error return arg;&#125; 三、总结上面总结了TypeScript的基本用法，这些用法算是TS中最基础的，但是是实际开发中用到最多的，二八原则，先花20%的时间学会80%的东西，剩下的高阶用法等到该用了，自然就会用了。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>TypeScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node前端线上部署与基础运维]]></title>
    <url>%2Fposts%2FnodeDeploy%2F</url>
    <content type="text"><![CDATA[一、Linux基础相关1、在Linux系统中安装node程序，Linux系统常用的有Ubuntu，centOS等，如果不能确定Linux具体的系统版本，可以通过命令查看.1$ cat /etc/redhat-release 2、常用的安装方法是使用已编译好的版本，也可以通过编译安装，好处就是可以获取最新版，但是坑比较多。 1234$ wget https://nodejs.org/dist/v10.9.0/node-v10.9.0-linux-x64.tar.xz // 下载$ tar xf node-v10.9.0-linux-x64.tar.xz // 解压$ cd node-v10.9.0-linux-x64/ // 进入解压目录$ ./bin/node -v // 查看版本 123// 使用ln命令来设置软链接$ ln -s /usr/software/nodejs/bin/npm /usr/local/bin/$ ln -s /usr/software/nodejs/bin/node /usr/local/bin/ 比较简单的可以直接通过EPEL安装，EPEL库安装的版本相对较低,可以通过安装node 版本工具 n 来进行管理。12$ Sudo yum install epel-release$ sudo yum install nodejs 3、安装pm2 node 的管理工具全局安装 1$ npm install pm2 -g pm2 管理node程序的好处 内建负载均衡支持性能监控0 秒停机重载，我理解大概意思是维护升级的时候不需要停机.具有 Ubuntu 和 CentOS 的启动脚本停止不稳定的进程（避免无限循环）服务器重新启动时自动重新启动自动化部署(没研究) pm2常用命令 123456789101112// 启动node程序$ pm2 start app.js// 列出所有进程$ pm2 list// 删除进程$ pm2 delete 0// 重启进程$ pm2 restart app// 查看日志$ pm2 logs app// 设置pm2 开机自启(centos 下)$ pm2 startup centos 4、vim 文本编辑器 相关命令Vim 文本编辑在类unix系统中使用广泛，主用用来编辑文件内容，针对前端来说，平时简单修改配置，个人觉得只需要熟练记住几个常用命令既可，如图： 截止目前我常用的就是编辑nginx配置，拿nginx举例基本操作如下：12345678// 切换 root 账户$ sudo su root// 查看nginx配置$ vim /etc/nginx/nginx.conf// 基本命令$ a 进入编辑 :wq 保存退出 :q! 不保存退出 ESC 退出编辑状态// 重启nginx 服务$ nginx -s reload 二、项目部署1、文件上传(通过Jenkins自动化构建)如果没有配置Jenkins 也可以手动通过命令上传 1$ scp -r -P 10086 /Users/ronluo/Desktop/h5/gaia-flexi-cms-team/maya-server/dist devops@47.102.207.109:/home/devops/flexi-fuwu/Maya-server/dist 2、node服务启动服务器上传node dist包，使用pm2 启动，因为后台服务和前台放置在同一服务器，所以可以把后台地址配置为内网地址127.0.0.1:8809，然后node中的public指向前端静态文件。 配置ngnix反向代理到node的端口，可以不使用ngnix去反向代理，也可以联系运维直接将域名指向node端口，但是找别人太麻烦，所以直接通过ngnix反向代理到node端口。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>node</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[input 调用相机和HTML5 getUserMedia API 实现图片的拍照加水印功能]]></title>
    <url>%2Fposts%2FwaterMark%2F</url>
    <content type="text"><![CDATA[一、业务回顾&nbsp;&nbsp;&nbsp;&nbsp;之前接到过一个需求，需要用户在企业微信内使用我们的程序时，进行拍照功能，并添加水印后将水印图片存储至自己的阿里云图片服务器，本身需求并不难，因为以当时的了解，加水印可以直接canvas操作，然后只需要调用企业微信暴露的chooseImage 方法得到图片file信息就可以，但是too native，企业微信对img的localIds进行了一层封装，无法触发img的onload事件，canvas自然就没办法去捕获绘图，尝试过二进制数据流，FileReader去进行文件转换，最后都没办法绕过，坑了很久，最后想着大不了不用微信的chooseImage，我自己去掉原生的API，getUserMedia获取用户拍照信息，很遗憾，这个方法在企业微信禁用了，所以最后的实现方案成了在后台服务器端加水印，然后通过腾讯服务器中转来获取图片，虽然最后的方案不尽人意，但是过程中还是学到了很多，就点，可以来简单的总结下getUserMedia的用法。 二、getUserMedia API简介&nbsp;&nbsp;&nbsp;&nbsp;HTML5的getUserMedia API为用户提供访问硬件设备媒体（摄像头、视频、音频、地理位置等）的接口，基于该接口，我们可以在不依赖任何插件的条件下访问硬件媒体设备。getUserMedia API最初是navigator.getUserMedia，目前已被最新Web标准（2017版的）废除，变更为navigator.mediaDevices.getUserMedia(),但浏览器支持情况不如旧版API普及。所以实际业务场景中使用时，一般都会做一些兼容处理。MediaDevices.getUserMedia（）方法提示用户允许使用一个视频和/或一个音频输入设备，例如相机或屏幕共享和/或麦克风。如果用户给予许可，就返回一个Promise对象，MediaStream对象作为此Promise对象的Resolved状态的回调函数参数，如果用户拒绝了许可，或者没有媒体可用的情况下PermissionDeniedError或者NotFoundError作为此Promise的Rejected状态的回调函数参数。注意，由于用户不会被要求必须作出允许或者拒绝的选择，所以返回的Promise对象可能既不会触发resolve也不会触发 reject。 三、实际使用&nbsp;&nbsp;&nbsp;&nbsp;具体的使用方法其实也很简单,html如下，一个简单的video标签获取当前的媒体流，一个拍照按钮，一个canvas容器对图片进行水印处理。123&lt;video id="video" width="320" height="240" autoplay&gt;&lt;/video&gt;&lt;button id="btn"&gt;拍照&lt;/button&gt;&lt;canvas id="canvas" width="320" height="240" &gt;&lt;/canvas&gt; 简单的JS代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142var camera = &#123; video: document.getElementById('video'), canvas: document.getElementById('canvas'), btn: document.getElementById("btn"), font: "14px microsoft yahei", style: "rgba(255,255,255,0.9)", text: "这是我要加的水印", height: 240, width: 320, draw_pic: function()&#123; var self = this; var context = self.canvas.getContext('2d'); context.drawImage(self.video, 0, 0, self.width,self.height); context.font = self.font; context.fillStyle = self.style; context.fillText(self.text, self.width - 140 , self.height - 10); &#125;, bind: function()&#123; var self = this; self.btn.addEventListener("click", function() &#123; self.draw_pic(); &#125;); &#125;, init: function()&#123; var video = this.video; // 原来的navigator.mediaDevices 方法已废弃， window.URL.createObjectURL 已废弃 // 想要获取一个最接近 1280x720 的相机分辨率 var constraints = &#123; audio: true, video: &#123; width: 1280, height: 720 &#125; &#125;; navigator.mediaDevices.getUserMedia(constraints) .then(function(mediaStream) &#123; video.srcObject = mediaStream; // 指定视频/音频（audio/video）的元数据加载后触发 video.onloadedmetadata = function(e) &#123; video.play(); &#125;; &#125;).catch(function(err) &#123; console.log(err.name + ": " + err.message); &#125;); this.bind(); &#125;&#125;;camera.init(); &nbsp;&nbsp;&nbsp;&nbsp;实现效果如图，当用户调用相机时，获取视频流，然后将视频流设置为video元素的源，然后播放视频，点击拍照时绘制当前照片页面。 当然，功能很简单，注意事项还是不少的，例如我刚才开始写的时候是用的window.URL.createObjectURL方法去设置视频流，但是一直有问题，Google发现属性已经废弃，可以直接video.src = stream,来使用视频流。但因为老版浏览器对旧属性支持更好所以用try catch做了兼容处理。针对上面用到的onloadedmetadata方法，这边有一些关于video视频元数据加载的执行顺序钩子：onloadstart、ondurationchange、onloadedmetadata、onloadeddata、onprogress、oncanplay、oncanplaythrough. 四、再次接触图片加水印&nbsp;&nbsp;&nbsp;&nbsp;上面提到需求拍照加水印最后虽然实现了，但是是服务器端实现，占用服务器带宽，再加上现在手机拍照动辄十几M的图片大小，我们这个功能使用的客户数在两万左右，而且大概率是集中使用，这样就会导致服务器压力很大，当然，企业微信那块我们是真没办法处理，所以产品就把功能加在了标准版没有了企业微信的一系列限制，我们就可以大展手脚了，综合调研下，我们决定用input标签的 accept=”image/*” capture=”camera” 属性来实现仅调用相机，不从相册上传的限制，但是这个属性是有兼容问题，目前使用下来，除ios10.. 版本系统还是会提示从相机选择外，其他机型都是完美兼容的，既然客户同意，那咱开发自然肯定是没啥意见，功能点的实现大致是有以下几个坑。 1、input兼容：就是刚刚提到的input 仅调用相机的兼容问题 2、img图片渲染：对img元素加水印时，onLoad 事件的执行顺序问题。 3、前端图片压缩：现在的手机拍摄照片过大，上传服务器有较大压力，如果功能对图片质量要求不是很高的话，对图片进行压缩也是必须的。 4、IOS 拍照图片旋转角问题。 5、canvas绘图后图片失真问题。 6、图片转为二进制流数据传输时，toBlob 方法的兼容问题。 既然理论和坑都已经大致说在前面了，剩下的就是开始撸代码了，功能其实还是比较简单的，主要是踩坑过程比较艰辛，话不多说，上代码：1&lt;input type="file" onChange='onFileSelected(event)' accept="image/*" capture="camera" /&gt; 为了demo简单，就将获取图片和加水印写在了一个方法里：123456789101112131415161718192021222324252627282930313233343536373839// 参数为:file文件,水印内容，图片大小Watermark = (file, text, maxWidth = 400) =&gt; &#123; return new Promise((resove, reject)=&gt;&#123; // 上传之前通过FileReader方法去预览图片 let reader = new FileReader(); reader.onload = (e)=&gt;&#123; let image = new Image(); image.src = e.target.result; image.onload = () =&gt; &#123; let canvas = document.createElement('canvas'); let ctx = canvas.getContext('2d'); let &#123; width, height &#125; = this; if(maxWidth !== 0)&#123; width = Math.min(maxWidth, this.width); height = height * (width / this.width); &#125; canvas.width = width; canvas.height = height; // 水印内容 ctx.font='26px Roboto-Medium'; //字体 ctx.fillStyle = '#FFFFFF'; //字体颜色 ctx.fillText(text, 20, 35); // 如果需要base64的格式传输 let base64 = canvas.toDataURL('image/png'); resolve(base64); // 如果需要二进制流传输 canvas.toBlob( blob =&gt; &#123; resolve(blob); &#125;; &#125; image.src = e.target.result; &#125; reader.onerror = reject; reader.readAsDataURL(file); &#125;)&#125; IOS 拍照旋转问题主要的代码结构其实已经完成，针对上面提到问题，可以增加适当的兼容代码，例如：IOS 拍照旋转问题，需要引入exif-js插件，做一下处理：1234567891011121314151617181920212223242526272829303132333435/** 获取照片方向角属性 */EXIF.getData(image, function()&#123; let orientation = EXIF.getTag(this, 'Orientation'); switch (orientation) &#123; /** 需要顺时针90度旋转 */ case 6: canvas.width = height; canvas.height = width; ctx.save(); ctx.translate(canvas.width / 2, canvas.height / 2); ctx.rotate(90 * Math.PI / 180); ctx.drawImage(image, 0 - canvas.height / 2, 0 - canvas.width / 2, canvas.height, canvas.width); ctx.restore(); break; /** 需要逆时针90度旋转 */ case 8: canvas.width = height; canvas.height = width; ctx.save(); ctx.translate(canvas.width / 2, canvas.height / 2); ctx.rotate(-90 * Math.PI / 180); ctx.drawImage(image, 0 - canvas.height / 2, 0 - canvas.width / 2, canvas.height, canvas.width); ctx.restore(); break; /** 需要180度旋转 */ case 3: ctx.save(); ctx.rotate(180 * Math.PI / 180); ctx.drawImage(this, -width, -height, canvas.width, canvas.height); ctx.restore(); break; default: ctx.drawImage(this, 0, 0, canvas.width, canvas.height); &#125;&#125;); IOS10.0版本以下，toBlob方法不存在的兼容方法1234567891011121314// 当canvas对象的原型中没有toBlob方法的时候，手动添加该方法if (!HTMLCanvasElement.prototype.toBlob) &#123; Object.defineProperty(HTMLCanvasElement.prototype, 'toBlob', &#123; value: function (callback, type, quality) &#123; var binStr = atob(this.toDataURL(type, quality).split(',')[1]), len = binStr.length, arr = new Uint8Array(len); for (var i = 0; i &lt; len; i++) &#123; arr[i] = binStr.charCodeAt(i); &#125; callback(new Blob([arr], &#123; type: type || 'image/png' &#125;)); &#125; &#125;);&#125; Canvas图片压缩还有就是Canvas图片压缩，图片压缩原理其实很简单，核心API就是使用Canvas的drawImage()方法，API大致如下：123context.drawImage(img, dx, dy);context.drawImage(img, dx, dy, dWidth, dHeight);context.drawImage(img, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight); 虽然参数很多，简单总结下其实可以归纳为如下三个参数： &nbsp;&nbsp;&nbsp;&nbsp; img : &nbsp;&nbsp;图片对象,也可以是虚拟DOM中的图片对象 &nbsp;&nbsp;&nbsp;&nbsp; dx, dy, dWidth, dHeight : &nbsp;&nbsp;表示在canvas画布上规划处一片区域用来放置图片，dx, dy为canvas元素的左上角坐标，dWidth, dHeight指canvas元素上用在显示图片的区域大小。如果没有指定sx,sy,sWidth,sHeight这4个参数，则图片会被拉伸或缩放在这片区域内。 &nbsp;&nbsp;&nbsp;&nbsp; sx, sy, swidth, sheight : &nbsp;&nbsp;这4个坐标是针对图片元素的，表示图片在canvas画布上显示的大小和位置。sx,sy表示图片上sx,sy这个坐标作为左上角，然后往右下角的swidth,sheight尺寸范围图片作为最终在canvas上显示的图片内容。当然，为了方便我个人一般都是用五个参数的语法，我们举个例子，假如一张图片的尺寸是1024 * 800，我们需要限制为102 * 80，核心代码：12...ctx.drawImage(img,0,0,102,80); 其实就这么一句代码就实现了图片压缩，有木有很简单。 Canvas绘图容易失真的问题&nbsp;&nbsp;&nbsp;&nbsp;最后还有一个关于Canvas绘图容易失真的问题，这块内容主要涉及到devicePixelRatio 设备像素比，这块的话，大家可以去看张鑫旭的这篇文章：文章地址 这块对devicePixelRatio属性进行了很详细的介绍，实际我们解决canvas画图模糊就是画一个两倍于实际大小的canvas，简单解释就是devicePixelRatio属性决定了用几个像素点渲染一个像素，假如某个屏幕的devicePixelRatio值为2，一张100 * 100像素的图片会用两个像素点渲染，实际图片其实会占据200 * 200像素空间，所以我们需要直接创建一个两倍实际大小canvas，然后用css样式把canvas限定在实际的大小，具体核心代码如下：123456789101112...var devicePixelRatio = window.devicePixelRatio || 1;var backingStoreRatio = context.webkitBackingStorePixelRatio || context.mozBackingStorePixelRatio || context.msBackingStorePixelRatio || context.oBackingStorePixelRatio || context.backingStorePixelRatio || 1; var ratio = devicePixelRatio / backingStoreRatio; canvas.width = canvas.width * ratio; canvas.height = canvas.height* ratio; context.scale(ratio, ratio);... 总结&nbsp;&nbsp;&nbsp;&nbsp;嗯，到这里这篇文章差不多就要结束了，说的有点乱，大致就是前端实现图片上传，加水印，和后台数据传输（base64，二进制流）实现过程中的一些坑和注意事项，如有错误，不吝指教。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>canvas</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结(六) JavaScript篇(二)]]></title>
    <url>%2Fposts%2FsummaryJs2%2F</url>
    <content type="text"><![CDATA[一、写在前面的叨叨叨&nbsp;&nbsp;&nbsp;&nbsp;前两周整理一些比较核心的Js的基础，这两周又收集了一些问题和知识点，拿到这篇文章来整理回顾下，大部分其实都是一些初级面试经常问的， 可以作为一个题库，等需要面试的时候刷刷也是极好的。这段时间晚上都在追庆余年，之前拿出来学习的时间也少了又少，不过剧终于追完了，也是该更新下博客拉！ 二、Js基础梳理1、创建对象的多种方式 通过”字面量“方式创建。将成员信息写到{}中，并赋值给一个变量，此时这个变量就是一个对象。 通过”构造函数“方式创建。 var obj = new 函数名(); 通过object方式创建。通过object构造器new一个对象，再往里丰富成员信息。 2、变量提升(hoisting)JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。变量可以在使用后声明，也就是变量可以先使用再声明。 3、举例说明一个匿名函数的典型用例自执行函数，用闭包模拟私有变量、特权函数等。 4、DOM事件的绑定的几种方式 在DOM元素中直接绑定。 在JavaScript代码中绑定; 绑定事件监听函数。 5、DOM事件中target和currentTarget的区别 target:触发事件的某个具体对象，只会出现在事件流的目标阶段； currentTarget:绑定事件的对象，恒等于this，可能出现在事件流的任意一个阶段中。 6、手写Ajax，XMLHttpRequestXMLHttpRequest对象的本质：可以发送Http请求，处理Http响应，与服务器之间进行异步交换数据的对象，其核心是Http.具体实现步骤：1、创建XMLHttpRequest对象。2、指定响应函数。3、打开连接（指定请求）4、发送请求。5、创建响应函数。1234567891011121314151617181920212223242526// 声明一个变量，用来实例化XMLHttpRequest对象var xmlhttp=null;if (window.XMLHttpRequest)&#123; // 新浏览器直接创建XMLHttpRequest对象 xmlhttp = new XMLHttpRequest( );&#125;else if(window.ActiveXObject)&#123; // IE5或IE6没有XMLHttpRequest对象，而是用的ActiveXObject对象 Xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");&#125;if (xmlhttp !== null) &#123; // 指定响应函数为state_Change xmlhttp.onreadystatechange=state_Change; // 指定请求，这里要访问note.xml文件，true代表的使用的是异步请求 xmlhttp.open("GET","note.xml",true); xmlhttp.send(null);//发送请求&#125; else&#123; alert("你得浏览器不支持XMLHTTP."); &#125;// 创建具体的响应函数state_Changefunction state_Change()&#123; if (xmlhttp.readyState === 4)&#123; if (xmlhttp.status === 200)&#123; // 这里应该是函数具体的逻辑 &#125;else&#123; alert("Problem retrieving XML data") ;&#125; &#125;&#125; 7、JS原生对象、内置对象、宿主对象。&nbsp;&nbsp;&nbsp;&nbsp; 原生（Naitve）对象： 独立于宿主环境的 ECMAScript实现提供的对象，包含：Object、Function、Array、String、Boolean、Number、Date、RegExp、Error、EvalError、RangeError、ReferenceError、SyntaxError、TypeError、URIError，简单来说，本地对象就是 ECMA-262 定义的类（引用类型）。&nbsp;&nbsp;&nbsp;&nbsp; 内置（Build-in）对象： 由 ECMAScript实现提供的、独立于宿主环境的所有对象，在 ECMAScript程序开始执行时出现，而ECMA-262 只定义了两个内置对象，即 Global 和 Math，内置对象是原生对象的一种。&nbsp;&nbsp;&nbsp;&nbsp; 宿主（host）对象： 所有非本地对象都是宿主对象，所有的BOM和DOM都是宿主对象，ECMAScript官方未定义的对象都属于宿主对象。 8、document load 和 document DOMContentLoaded 两个事件的区别load是页面所有资源全部加载完成后（DOM文档树，css文件，js文件，图片资源等）; DOMContentLoaded：当页面文档加载并解析完毕之后会马上出发 DOMContentLoaded 事件，而不会等待样式文件、图片文件和子框架页面的加载。 9、什么是“use strict”,好处和坏处use strict: 意味着代码按照严格模式解析，这种模式使得Javascript在更严格的条件下运行。好处: 消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为，消除代码运行的一些不安全之处，保证代码运行的安全；提高编译器效率，增加运行速度；坏处: 同样代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。 10、JS如何实现重载和多态 根据arguments个数实现重载, arguments检测传参个数，执行不同的方式。 JavaScript中大多是通过子类重写父类方法的方式实现多态。 11、浅拷贝(Shallow Copy)和深拷贝(Deep Copy)浅拷贝： 复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。浅拷贝实现方式： 1、简单地复制语句。 2、Object.assign() (ES6)深拷贝： 创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。实现方式： 1、用 JSON.stringify 把对象转成字符串，再用 JSON.parse 把字符串转成新的对象。 2、Object.create()。 3、递归拷贝（注意避免互相引用导致死循环） 12、CSSOM视图模式(CSSOM View Module) Window视图属性 innerWidth 和 innerHeight：window窗体的内部宽度(高度)不包括窗框。 outerWidth 和 outerHeight: 表示整个浏览器窗体的大小，包括任务栏。 pageXOffset 和 pageYOffset: 整个页面滚动的像素值(水平方向和垂直方向的)。 screenX 和 screenY: 浏览器窗口在显示器中的位置(screenX水平screenY垂直)。 Screen视图属性 availWidth 和 availHeight: 显示器可用宽高，不包括任务栏等。 colorDepth: 表示显示器的颜色深度。 width和height: 表示显示器屏幕的宽高。 文档(DocumentView)视图属性 elementFromPoint: 返回给定坐标处所在的元素。 getBoundingClientRect: 得到矩形元素的界线，返回的是一个对象，包含 top, left, right, 和 bottom四个属性值，大小都是相对于文档视图左上角计算而来。 scrollIntoView: 让元素滚动到可视区域。 元素(DocumentView)视图属性 clientLeft 和 clientTop: 表示内容区域的左上角相对于整个元素左上角的位置（包括边框）。 clientWidth 和 clientHeight: 表示内容区域的高度和宽度，包括padding大小，但是不包括边框和滚动条。 offsetLeft 和 offsetTop: 表示相对于最近的祖先定位元素（CSS position 属性被设置为 relative、absolute 或 fixed 的元素）的左右偏移值。 offsetWidth 和 offsetHeight: 整个元素的尺寸（包括边框）。 scrollLeft 和 scrollTop: 表示元素滚动的像素大小。 scrollWidth 和 scrollHeight: 表示整个内容区域的宽高，包括隐藏的部分。如果元素没有隐藏的部分，则相关的值应该等用于clientWidth和clientHeight。当你向下滚动滚动条的时候，scrollHeight应该等用于scrollTop + clientHeight。 鼠标位置(Mouse position)属性 clientX 和 clientY: 鼠标相对于window的偏移。 pageX, pageY: 鼠标相对于document的坐标。 screenX, screenY: 鼠标相对于显示器屏幕的偏移坐标。 13、常用的数组api，字符串api，Math对象，Date日期对象 数组API unshift(): 数组开头增加一个或多个元素，返回数组长度，原数组改变。 shift(): 删除数组第一个元素，返回被删除内的容，原数组改变。 push(): 数组末尾增加一个或多个元素，返回数组长度，原数组改变。 pop(): 删除数组末尾一项，返回被删除的内容，原数组改变。 concat(): 数组拼接，不改变原数组，返回被连接数组副本。不传参数可实现数组克隆。 splice(index, howmany, item1, ...itemx): 根据参数实现数组的删除，增加，替换。例: splice（index,0，item1，item2…)从索引index开始增加，增加的内容插入到索引index前面。 splice(index, n) 从索引index开始删除n个，如果只有一个参数splice(index)，就是从索引index开始后面的内容全部删除。 Splice(index,n，item1，item2..）从索引index开始替换n个,替换的内容为item1, item2….。 slice(n，m): 从索引 n 截取到索引 m 但不包括 m ,原数组不发生改变。 reverse(): 数组翻转,返回反转后新数组，原数组发生改变。 sort(): 数组排序,使用方法一般sort（function（a，b）{return a-b }）从小到大排。 toString(): 把数组转成以逗号分隔的字符串。 join（拼接形式）: 把数组拼接成以其他形式分割的字符串。 字符串API charAt(index): 通过索引找到该索引对应字符，包含空格。 charCodeAt(index): 通过索引找到该索引字符对应的Unicode编码(0-65535的整数）。 indexOf( ): 从前往后找，找到返回内容的索引，找不到返回-1。 lastIndexOf( ): 从后往前找，找到返回内容的索引，找不到返回-1。 slice(n，m): 从索引n 查找到索引m ,但不包括m，slice可以取负值。 substring(n，m): 从索引n 查找到索引m ，但不包括m， 不可以取负值。 substr（n，m): 从索引n开始截取m 个 split（切割形式）: 把一个字符串分割成字符串数组。 toUpperCase（） :转大写字母 toLowerCase（） :转小写字母 Math 对象API Math.floor( ): 向下取整 Math.ceil( ): 向上取整 Math.round( ): 四舍五入 Math.random( ): 取0-1之间的随机小数 Math.pow(x,y): x的y次幂 Math.abs( ): 取绝对值 Math.sqrt( )开平方 Math.max/min( ): 取最大/小值 Date日期对象API new Date( ): 创建一个日期对象 getFullYear() 返回年份 getMonth( ): 返回月份数（0-11）, 想要得到几月，需要加一 getDay( ): 返回一周的第几天（0-6），想要得到星期几，需要加一。 getDate( ): 返回日(号) getMinutes(): 返回分 getSeconds(): 返回秒 getTime( ): 返回从1970年1月1日00：00到现在的毫秒数，也就是时间戳。 setFullYear(yearInt): 设置年份4位数 setMonth(monthInt): 设置月份(0-11) setDate(dateInt): 设置日(1-31) setHours(hourInt): 设置小时数(0-23) setMinutes(minInt): 设置分钟数(0-59) setSeconds(secInt): 设置秒数(0-59) 14、正则表达式 正则表达式的创建 调用RegExp对象的构造函数var reg = new RegExp(&#39;^[a-z]+[0-9]$&#39;, &#39;gi&#39;)其中第一个参数是匹配模式，第二个参数是可选参数(g, i, m),分别用于指定全局匹配、区分大小写的匹配和多行匹配。 使用正则表达式字面值(var reg = /^[a-z]+[0-9]$/gi) 正则表达式的组成 元字符: .匹配除了换行符(n)以外的所有字符,w匹配字母，数字，或者汉字,W匹配除了字母，数字，汉字以外的其他字符,d匹配数字,D匹配除了数字以外的其他字符, s匹配任意的空白符(f, n, r, t, v), S匹配空白符以外的任意字符, b匹配单词的开始或者结束, B匹配单词的非开始或者结束, ^匹配行首, $匹配行尾。 转义字符(\): * + ? | { [ ( ) ] }^ $ . # 和空白需要转义。 限定符: *匹配零次至多次，+匹配一次至多次，？匹配零次或一次{2,}至少匹配两次，{10}匹配10次，{2, 8}至少匹配两次至多匹配八次。 正则表达式的方法 test： 检索字符串中的指定子串，返回布尔值。 exec: 返回一个数组，数组中的第一个条目是第一个匹配。 search: 返回子串的开始位置 match: 返回匹配到的子串 replace: 替换匹配到的子串 split: 将字符串分割成数组 // &#39;a12b2334c34&#39;.split(/\d{4}/) [&quot;a12b&quot;, &quot;c34&quot;] 15、js 处理异常，调试方法处理异常： try catch调试方法： 1、打印到控制台。2、记录到当前页面。3、抛出错误 三、写在后面的叨叨叨&nbsp;&nbsp;&nbsp;&nbsp; 不知不觉又到了深夜，渐渐的喜欢上了夜深人静的时候整理代码的感觉，这次比自己想象的整理的要多一些，除了正则花费了些功夫重新整理梳理了外，其他内容大多都是一些API文档，自己从头又过了下，虽然很多东西都过时了，例如indeOf早已可以用Es6的includes 方法去替代，语义和用法都好用很多，但是过一遍基础api也没啥坏处，明天周一，不过下周还是比较爽的元旦周三，上两天又休息了，美滋滋，加油!]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结(五) JavaScript篇(一)]]></title>
    <url>%2Fposts%2FsummaryJs1%2F</url>
    <content type="text"><![CDATA[一、写在前面的叨叨叨&nbsp;&nbsp;&nbsp;&nbsp;之前用了四篇对Html,Css进行了总结，从这篇开始就是对Js进行一些温习回顾，在实际业务中框架用的多了，对一些原生属性是越来越不熟悉了，一些基础的操作dom的方法慢慢的也越来越手生了，正好这个机会整理一波，JS和css，html一样也只是针对性的挑了一些比较经典和基础的内容来进行总结。 二、Js基础梳理1、js的基本类型有哪些？引用类型有哪些？引用类型和基本类型有什么区别？null 和 undefined 的区别。&nbsp;&nbsp;&nbsp;&nbsp;值类型(基本类型)：数值(number)、布尔值(boolean)、null、undefined、string(字符串)、Symbol。&nbsp;&nbsp;&nbsp;基本类型的值是不可变的，比较是它们的值的比较，数据类型不同也可以进行值比较，因为会进行数据类型的隐式转换。基本类型的变量是存放在栈内存（Stack）里的，栈内存中包括了变量的标识符和变量的值。&nbsp;&nbsp;&nbsp;引用类型：对象(Object)、数组（Array）、函数(Function)、RegExp、Date 类型。&nbsp;&nbsp;&nbsp;引用类型的值是可变的，比较是它们引用的比较，引用类型的值是保存在堆内存（Heap）中的对象（Object）。栈内存中保存了变量标识符和指向堆内存中该对象的指针，堆内存中保存了对象的内容。&nbsp;&nbsp;&nbsp; null 表示”没有对象”，即该处不应该有值。典型用法是：&nbsp;&nbsp;&nbsp; （1） 作为函数的参数，表示该函数的参数不是对象。&nbsp;&nbsp;&nbsp; （2） 作为对象原型链的终点。&nbsp;&nbsp;&nbsp; undefined 表示”缺少值”，就是此处应该有一个值，但是还没有定义。典型用法是：&nbsp;&nbsp;&nbsp; （1） 变量被声明了，但没有赋值时，就等于undefined。&nbsp;&nbsp;&nbsp; （2） 调用函数时，应该提供的参数没有提供，该参数等于undefined。&nbsp;&nbsp;&nbsp; （3） 对象没有赋值的属性，该属性的值为undefined。&nbsp;&nbsp;&nbsp; （4） 函数没有返回值时，默认返回undefined。 2、如何判断对象类型 typeof 操作符适合判断基本类型，不适合判断引用类型（都返回object），比如自定义的对象类型。如果我们想要判断一个变量是否存在，可以使用typeof a != “undefined” instanceOf操作符判断一个实例是否存在于某对象的原型链上 用对象的 constructor 来判断对象类型当检测null或者undefined类型的constructor 属性时，js会报错，不推荐使用 Object.prototype.toString.call(object) （主流建议方法）形式 Object.prototype.toString.call(object).slice(8,-1).toLowerCase(); 3、JS常见的DOM操作API基本概念：浏览器为JavaScript提供的一系列接口。Node有一个属性nodeType表示Node的类型，它是一个整数，其数值分别表示相应的Node类型。 Element类型：提供了对元素标签名，子节点和特性的访问，nodeType为1。 Attr类型：表示元素的特性，nodeType值为2。 Text类型：表示文本节点，它包含的是纯文本内容，nodeType为3。 Comment类型：表示HTML文档中的注释，nodeType为8。 Document：表示文档，document对象是HTMLDocument的一个实例，nodeType为9。DocumentFragment类型：表示一种轻量级的文档，nodeType为11。 &nbsp;&nbsp;&nbsp;&nbsp; a、节点创建API（用来创建节点） createElement (创建元素)&nbsp;&nbsp; Document.createElement()通过传入指定的一个标签名来创建一个元素. createTextNode (创建文本)&nbsp;&nbsp; Document.createdTextNode()传入文本节点中的文本 cloneNode (复制节点)&nbsp;&nbsp; 返回调用方法的节点的一个副本，它接收一个bool参数，用来表示是否复制子元素，为真表示复制子元素，为假表示只复制parent节点。parent.cloneNode(true);。如复制的元素有id，则其副本同样包含该id，所以复制节点后必须要修改其id。 createDocumentFragment （创建一个DocumentFragment）&nbsp;&nbsp; 主要是用于添加大量节点到文档中时会使用到，可以先将节点添加到fragment，最后一次性添加到文档，因为DocumentFragment不是文档树的一部分，它是保存在内存中的，所以不会造成回流问题。 &nbsp;&nbsp;&nbsp;&nbsp; b、页面修改API(用来修改页面DOM) appendChild (插入到末尾)&nbsp;&nbsp; 将指定的节点添加到调用该方法的节点的子元素的末尾，如果被添加的节点是一个页面中存在的节点，则执行后这个节点将会添加到指定位置，其原本所在的位置将移除该节点 insertBefore （添加一个节点到一个参照节点之前）&nbsp;&nbsp; 例：parentNode.insertBefore(newNode,refNode)，parentNode表示新节点被添加后的父节点，newNode要添加的节点，refNode参照节点，新节点添加到这个节点之前。refNode是必传的，如果不传该参数会报错。 removeChild （删除指定子节点） replaceChild （用于使用一个节点替换另一个节点）&nbsp;&nbsp; 例：parent.replaceChild(newChild,oldChild);newChild是替换的节点，可以是新的节点，也可以是页面上的节点，如果是页面上的节点，则其将被转移到新的位置。oldChild是被替换的节点。 &nbsp;&nbsp;&nbsp;&nbsp; c、节点查询API document.getElementById()&nbsp;&nbsp; 根据元素id返回元素，返回值是Element类型，如果不存在该元素，则返回null。 document.getElementsByTagName()&nbsp;&nbsp; 根据元素标签名获取元素，返回一个即时的HTMLCollection类型 document.getElementsByName()&nbsp;&nbsp; 通过指定的name属性来获取元素，它返回一个即时的NodeList对象。 document.getElementsByClassName() （注：IE9+）&nbsp;&nbsp; 根据元素的class返回一个即时的HTMLCollection，如果要获取2个以上classname，可传入多个classname，每个用空格相隔。 document.querySelector（） （注：IE9+）&nbsp;&nbsp; 通过css选择器来查找元素，返回第一个匹配的元素，如果没有，则返回null。 document.querySelectorAll（）（注：IE9+）&nbsp;&nbsp; 返回的是所有匹配的元素，而且可以匹配多个选择符。 &nbsp;&nbsp;&nbsp;&nbsp; d、节点关系API parentNode和parentElement（父关系型）&nbsp;&nbsp; parentNode：表示元素的父节点，parentElement：返回元素的父元素节点，与parentNode的区别在于，其父节点必须是一个Element，如果不是，则返回null。 previousSibling、previousElementSibling、nextSibling、nextElementSibling&nbsp;&nbsp; previousSibling：节点的前一个节点，previousElementSibling：返回前一个元素节点，前一个节点必须是Element（注：IE9+）。nextSibling：节点的后一个节点，nextElementSibling：返回后一个元素节点，后一个节点必须是Element。（注：IE9+） childNodes、children、firstNode、lastNode、hasChildNodes（子关系型）&nbsp;&nbsp; childNodes：表示元素的子节点列表，children：返回是Element的子节点，firstNode：第一个子节点，lastNode：最后一个子节点。hasChildNodes：判断是否包含子节点。 &nbsp;&nbsp;&nbsp;&nbsp; e、元素属性API setAttribute (根据名称和值修改元素的特性)&nbsp;&nbsp; element.setAttribute(name, value); 其中name是特性名，value是特性值。如果元素不包含该特性，则会创建该特性并赋值。 getAttribute (返回指定的特性名相应的特性值)&nbsp;&nbsp; element.getAttribute(“id”)，如果不存在，则返回null或空字符串。 &nbsp;&nbsp;&nbsp;&nbsp; f、元素样式API window.getComputedStyle() 获取应用到元素后的样式&nbsp;&nbsp; window.getComputedStyle(element[, pseudoElt]) element是要获取的元素，pseudoElt指定一个伪元素进行匹配。返回的style是一个CSSStyleDeclaration对象。通过style可以访问到元素计算后的样式. getBoundingClientRect() 返回元素的大小以及相对于浏览器可视窗口的位置&nbsp;&nbsp; clientRect是一个DOMRect对象，包含left，top，right，bottom，它是相对于可视窗口的距离，滚动位置发生改变时，它们的值是会发生变化的。除了IE9以下浏览器，还包含元素的height和width等。 4、解释一下事件捕获和事件冒泡，事件委托，如何阻止冒泡,阻止默认事件。DOM2级事件规定的事件流的三个阶段：事件捕获阶段，处于目标阶段，事件冒泡阶段。 事件捕获：从document到触发事件的那个节点，即自上而下的去触发事件，触发顺序为自外向内。事件冒泡：事件冒泡是自下而上的去触发事件，直到document/window。个人理解，事件冒泡存在的意义，就是在事件运行过程中，避免使用循环遍历的方式去给每个同级元素触发相同的事件，而优化性能。事件委托：事件委托就是利用事件冒泡，只指定一个事件处理程序，就可以管理某一类型的所有事件。（经典取快递例子理解）&nbsp;&nbsp; addEventListener(event,fn,false)方法用于向指定元素添加事件，事件方法的第三个参数，就是控制事件触发顺序是否为事件捕获。true,事件捕获；false,事件冒泡。默认false,即事件冒泡。阻止冒泡： event.stopPropagation()（注：IE9+）阻止默认行为：event.preventDefault() 5、 js 的作用域有几种？函数的作用域是什么？&nbsp;&nbsp;&nbsp; 一般说三种：全局、函数 和 eval作用域。作用域又称执行环境，所有变量都存在于一个执行环境（作用域）中，这个执行环境决定了变量的生命周期，以及哪一部分代码可以访问其中的变量，每进入一个执行环境都会创建一个用于搜索变量和函数的作用域链。作用域链本质是一个指向变量对象的指针列表，它只引用但不实际包含变量对象。作用域在函数定义时就已经确定，而不是在函数调用时确定。作用域中变量的值是在执行过程中产生的确定的，而作用域却是在函数创建时就确定了。 6、对闭包的理解？什么时候构成闭包？闭包的优缺点？&nbsp;&nbsp;&nbsp; 当在函数内部定义了其他函数时（引用了父作用域变量）就创建了闭包，闭包有权访问包含函数内部的所有变量。在执行环境中，闭包的作用域链包含着它自己的作用域，包含函数的作用域，全局作用域，通常函数的作用域及其变量都会在函数执行结束后被销毁，但当函数返回一个闭包时，这个函数的作用域将会一直在内存中保存到闭包不存在为止。 优点：可以读取函数内部的变量。实现私有作用域（封装插件） 缺点：创建闭包必须维护额外的作用域，过度使用会占用大量内存。 7、显示原型和隐式原型，手绘原型链，原型链是什么&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建的每个函数都有prototype（原型）属性，这个属性是个指针，指向一个对象（通过调用构造函数而创建的那个对象实例的原型对象）。 每个对象都有一个__proto__属性，可成为隐式原型.指向创建该对象的函数的prototype。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每个构造函数都有一个原型对象，原型对象包含一个指向构造函数的指针(constructor)，而实例包含一个指向原型对象内部的指针（__prototype__）。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;原型链：访问一个对象的属性时，先在基本属性中查找，如果没有，再沿着proto这条链向上找。原型链是实现继承的主要方法。 8、实现继承的多种方式和优缺点 原型链(缺点：包含引用类型值的原型属性会被所有实例共享，创建子类型实例时，不能向超类型的构造函数中传参) 借用构造函数（方法都在构造函数中定义，函数无法复用） 组合继承（原型链+构造函数）*推荐用法 使用原型链实现对原型属性和方法的继承，而通过借用构造函数来实现实例属性的继承。 原型式继承 Object.creat() IE9+ 9、this有哪些使用场景？如何改变this的值（call，apply，bind）？&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;this对象是在运行时基于函数的执行环境绑定的：在全局函数中，this等于window，当函数被作为某个对象的方法掉用时，this等于那个对象，不过匿名函数的执行环境具有全局性，因此其this通常指向window。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;唯一的一个不同就是采用了function.call或者function.apply的情况，function的this指向了call的传参，但这恰恰是针对上述this指向调用者的情况的一种补充，专用于调整this指向的。 10、new 一个对象（构造函数）具体做了什么 1.创建一个新对象 2.将构造函数的作用域赋给新对象（因此this就指向了这个新对象） 3.执行构造函数中的代码（为这个新对象添加属性） 4.返回新对象 三、写在后面的叨叨叨&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;本来自己是单独整理了20个左右的题目，放在这篇文章中自己去总结回答，但是没想到会花费那么多的时间，这十个题目差不多也包含了js最难得那几块，原型链，闭包，继承之类的，虽然我写的很简单，但是资料查了很多，总结的话也是自己通过查资料后自己理解后进行总结的并没有照搬其他的文章，除了一些标准的API之类的东西，总之时间是花了比较久的，所以暂时只整理了这些，等下次有时间接着撸其他问题。感谢阅读。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结(四) Css进阶Css3、Sass篇]]></title>
    <url>%2Fposts%2FsummaryCss3%2F</url>
    <content type="text"><![CDATA[一、简单介绍&nbsp;&nbsp;&nbsp;&nbsp;前段时间已经整理过两篇关于Css文章，一个是基础，一个是布局相关，这篇就整理了一下关于Sass的相关内容，Css3 在前面也提到过，像Flex布局之类的，这篇会介绍下Css3的简单新特性和动画相关，然后一些Sass用法，很多以前用的东西不去查文档很多都想不起来了，所以发现经常的去整理温习下确实也挺有必要，温故而知新嘛，废话少说，下面是文章的核心内容~ 二、Css3整理1、CSS3新特性，伪类，伪元素，锚伪类 动态伪类：（并不存在于HTML中,当用户和网站交互的时候才能体现出来） . property a:link { color:gray; } 链接没有被访问时前景色为灰色 . property a: visited { color: yellow; } 链接被访问过后前景色为黄色 . property a: hover { color: green; } 鼠标悬浮在链接上时前景色为绿色 . property a: active { color: blue; } 鼠标点钟激活链接那一下前景色为蓝色注：先后顺序，遵守爱恨原则LoVe/HAte,也就是Link–visited–hover—active；对于:hover在IE6下只有a元素支持，:active只有IE7-6不支持，:focus在IE6-7下不被支持。:focus用于元素成为焦点，这个经常用在表单元素上。 UI元素状态伪类： :enabled,:disabled,:checkedIE6-8不支持”:checked”,”:enabled”,”:disabled”这三种选择器。 CSS3的:nth选择器： :first-child 选择某个元素的第一个子元素； :last-child 选择某个元素的最后一个子元素； :nth-child() 选择某个元素的一个或多个特定的子元素； :nth-last-child() 选择某个元素的一个或多个特定的子元素，从这个元素的最后一个子元素开始算； :nth-of-type() 选择指定的元素； :nth-last-of-type() 选择指定的元素，从元素的最后一个开始计算； :first-of-type 选择一个上级元素下的第一个同类子元素； :last-of-type 选择一个上级元素的最后一个同类子元素； :only-child 选择的元素是它的父元素的唯一一个了元素； :only-of-type选择一个元素是它的上级元素的唯一一个相同类型的子元素； :empty 选择的元素里面没有任何内容 否定选择器（：not） 否定选择器 :not()，可以让你定位不匹配该选择器的元素。IE6-8浏览器不支持:not()选择器 伪元素（两个“：：”和一个“：”css3中主要用来区分伪类和伪元素） ::first-line：选择元素的第一行 ::first-letter：选择元素的第一个字母 ::before和::after：这两个主要用来给元素的前面或后面插入内容，这两个常用”content”配合使用，见过最多的就是清除浮动 ::selection：用来改变浏览网页时选中文字的默认效果 2、css3动画transform，transition和animation的区别 transform(2D变换) translate(x,y)：沿着 X 和 Y 轴移动元素。 rotate(angle)：旋转，在参数中规定角度。 scale(x,y)：缩放转换，改变元素的宽度和高度。 skew(x-angle,y-angle)：倾斜转换，沿着 X 和 Y 轴。 matrix(n,n,n,n,n,n)：定义 2D 转换，使用六个值的矩阵。 transition（过渡）Tip: transition允许css的属性值在一定的时间区间内平滑地过渡。这种效果可以在鼠标单击、获得焦点、被点击或对元素任何改变中触发，并圆滑地以动画效果改变CSS的属性值。兼容性：IE10+，Firefox, Opera 和 Chrometransition属性的值包括以下四个： transition-property： 指定对HTML元素的哪个css属性进行过渡渐变处理，这个属性可以是color、width、height等各种标准的css属性。 transition-duration：指定属性过渡的持续时间 transition-timing-function：指定渐变的速度： ease：（逐渐变慢）默认值 linear：（匀速） ease-in：(加速) ease-out：（减速） ease-in-out：（加速然后减速） cubic-bezier：（该值允许你去自定义一个时间曲线）， 特定的cubic-bezier曲线。 (x1, y1, x2, y2)四个值特定于曲线上点P1和点P2。所有值需在[0, 1]区域内，否则无效。 transition-delay：指定延迟时间，也就是经过多长时间才开始执行过渡过程。 animation（动画）需要配合@keyframes使用，语法规则:命名是由”@keyframes”开头，后面接着 “动画的名称”加上一对花括号“{}”，括号中就是一些不同时间段样式规则。不同关键帧是通过from（相当于0%）、to（相当于100%）或百分比来表示。@keyframes定义好后，须通过animation把它绑定到选择器。animation的属性如下： Animation：所有动画属性的简写属性（除了animation-play-state 属性）。 animation-name：规定 @keyframes 动画的名称。 animation-duration：规定动画完成一个周期所花费的秒或毫秒,默认是0。 animation-timing-function：规定动画的速度曲线，默认是”ease”。 animation-delay：规定动画何时开始，默认是 0 animation-iteration-count：规定动画被播放的次数，默认是 1（infinite：无限次） animation-direction：规定动画是否在下一周期逆向地播放。默认“normal”（reverse：反向播放；alternate：奇数次正向播放，偶数次反向播放；alternate-reverse：奇数次反向播放，偶数次正向播放。） animation-play-state：规定动画是否正在运行或暂停，默认是“running”（paused：暂停动画）。 三、Sass整理Sass和Less两者都是CSS预处理器，具有相同的功能，快速编译代码，更好的维护样式代码。不同点在于语法规则不同，相比less，sass更像一门正规的编程语言，有变量和作用域，变量有全局和局部之分，并且有优先级。有函数的概念，进程控制，数据结构。相同点在于： 混入(Mixins)——class中的class； 参数混入——可以传递参数的class，就像函数一样； 嵌套规则——Class中嵌套class，从而减少重复的代码； 运算——CSS中用上数学； 颜色功能——可以编辑颜色； 名字空间(namespace)——分组样式，从而可以被调用； 作用域——局部修改样式； JavaScript 赋值——在CSS中使用JavaScript表达式赋值。 a、Sass基本用法：&nbsp;&nbsp;&nbsp;&nbsp;1、变量（SASS允许使用变量，所有变量以$开头，如果变量需要镶嵌在字符串之中，就必须需要写在#{}之中)。1234$blue: #1875e7;div &#123; color: $blue&#125; &nbsp;&nbsp;&nbsp;&nbsp;2、计算功能（SASS允许在代码中使用算式：)。1234body &#123; margin: (14px/2); top: 50px + 100px;&#125; &nbsp;&nbsp;&nbsp;&nbsp;3、嵌套（SASS允许选择器嵌套，属性也可以嵌套，在嵌套的代码块内，可以使用&amp;引用父元素（伪类）;)。 b、代码重用：&nbsp;&nbsp;&nbsp;&nbsp; 1、继承: SASS允许一个选择器，继承另一个选择器.12345678.class1 &#123; border: 1px solid #ddd;&#125;/* class2要继承class1，需要使用 @extend 命令*/.class2 &#123; @extend .class1; font-size: 120%;&#125; &nbsp;&nbsp;&nbsp;&nbsp; 2、Mixin: (定义可重用代码块)，mixin的强大之处，在于可以指定参数和缺省值。123456789/* 使用 @mixin 命令，定义一个代码块 */@minxin left &#123; float: left; margin-left: 10px;&#125;/* 使用 @include 命令，调用 minxin */div &#123; @include left;&#125; &nbsp;&nbsp;&nbsp;&nbsp; 3、颜色函数（SASS提供了一些内置的颜色函数，以便生成系列颜色。）&nbsp;&nbsp;&nbsp;&nbsp; 4、插入文件（@import命令，用来插入外部文件。如果插入的是.css文件，则等同于css的import命令。） c、高级用法：&nbsp;&nbsp;&nbsp;&nbsp; 1、条件语句1234567891011/* @if 可以用来判断 */p &#123; @if 1 + 1 == 2 &#123; border: 1px solid; &#125; @if 5 &lt; 3 &#123; border: 2px detted; &#125;&#125;/* 一起的还有 @else 命令 */@if lightness($color) &gt; 30% &#123; background-color: #000;&#125; @else &#123; background-color: #fff;&#125; &nbsp;&nbsp;&nbsp;&nbsp; 2、循环语句1234567891011121314151617181920/* sass 支持 for 循环 */@for $i from 1 to 10 &#123; .border-#&#123;$1&#125; &#123; border: #&#123;$i&#125;px solid blue; &#125;&#125;/* while 循环 */$i: 6;@while $i &gt; 0 &#123; .item-#&#123;#i&#125; &#123; width: 2em * $i &#125; $i: $i - 2&#125;/* each 命令与for类似 */@each $member in a,b,c,d &#123; .#&#123;$member&#125; &#123; background=image: url("#&#123;$member&#125;.jpg"); &#125;&#125; &nbsp;&nbsp;&nbsp;&nbsp; 2、自定义函数12345678/* Sass 允许用户编写自己的函数 */@function double($n) &#123; @return $n * 2&#125;#sidebar &#123; width: double(5px);&#125; 四、最后&nbsp;&nbsp;&nbsp;&nbsp;到现在算是Css的内容告一段落了，虽然文章中看起来提到的东西并不多，但是每一点的整理和总结，资料的查找也颇费功夫，如果有不对的地方欢迎指正。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结(三) Css布局篇]]></title>
    <url>%2Fposts%2FsummaryCss2%2F</url>
    <content type="text"><![CDATA[一、简单介绍&nbsp;&nbsp;&nbsp;&nbsp;关于Css第一章的时候总结了一些常用的基础知识，但是没有涉及到布局相关的东西，大家都知道Css布局算是一个核心功能，兼容和问题包括布局方法也都很多，这次单独拿出来一个章节对布局进行一下总结，几种常见的布局写法，双飞翼布局，圣杯布局，还有Css3的Flex布局。正好今天是周末，阳光明媚的，午后晒晒太阳写点东西还是比较惬意的。 二、Css布局相关1、 grid布局(Grid layout)版本支持情况：IE10+（过时语法），Edge，chrome(57)，firefox(52)，opera(44) 术语：Grid container (display: gird 的元素。 这是所有grid item的直接父项)；Grid item： Grid 容器的孩子（直接子元素）。Grid line： 这个分界线组成的网格结构，即可是垂直(column),也可是水平(lines);Grid track: 两个相邻网格线之间的空间。Grid cell： 两个相邻的行和两个相邻的列网格线之间的空间。它是网格的一个“单元”。Grid Area: 四个网格线包围的总空间。 网格区域可以由任意数量的网格单元组成。API： 父容器(Grid Container)的属性 Display： 元素定义为grid contaienr，并为其内容建立新的网格格式化上下文.Grid：生成一个块级网格；inline-grid：生成一个行级网格；subgrid：从父节点获取行列大小。注：column, float, clear, 以及 vertical-align 对一个 grid container 没有影响。 grid-template-columns/grid-template-rows: 使用以空格分隔的多个值来定义网格的列和行。值表示轨道大小(track size)，之间的空格代表表格线(grid line)。例：grid-template-columns: 40px 50px auto 50px 40px;或grid-template-columns: [first] 40px [line2] 50px [line3] auto [col4-start] 50px [five] 40px [end]；另外grid-template-columns: 1fr 1fr 1fr;“fr”单位允许您将轨道大小设置为网格容器自由空间的一部分。自由空间是在排除所有不可伸缩的item 之后计算得到的。 grid-template-areas: 通过引用 grid-area属性指定的网格区域的名称来定义网格模板.grid-area-name:使用 grid-area 属性设置的网格区域的名称。.：点号代表一个空网格单元. None:没有定义网格区域。 grid-template： 在单个声明中定义 grid-template-rows、grid-template-columns、grid-template-areas 的简写。 grid-column-gap / grid-row-gap： 指定网格线的大小，可以理解为设置列/行之间的间距的宽度。注：只能在列/行之间创建缝隙，而不是在外部边缘创建。grid-row-gap 和 grid-column-gap可以简写为grid-gap：px px; justify-items: 沿着Y轴对齐网格内的内容；align-items,沿着X轴对齐；start: 内容与网格区域的左端对齐；end: 内容与网格区域的右端对齐； center: 内容位于网格区域的中间位置；stretch: 内容宽度占据整个网格区域空间(这是默认值)； justify-content/align-content： 有时，网格的总大小可能小于其网格容器的大小。此时，你可以设置网格容器内的网格的对齐方式。（justify Y轴，align X轴）。Start：网格与网格容器的左边对齐；End：网格与网格容器的右边对齐；Center： 网格与网格容器的中间对齐；Stretch：调整grid item 的大小，让宽度填充整个网格容器；Space-around：在 grid item 之间设置均等宽度的空白间隙，其外边缘间隙大小为中间空白间隙宽度的一半；Space-between：在grid item之间设置均等宽度空白间隙，其外边缘无间隙；Space-evenly：在每个 grid item 之间设置均等宽度的空白间隙，包括外边缘。 grid-auto-columns/grid-auto-rows: 指定自动生成的网格轨道（又名隐式网格轨道）的大小,简单理解就是当你指定的定位超过了网格范围的行或列时被创建。 子元素(Grid Items)的属性 grid-column-start/grid-column-end/grid-row-start/grid-row-end：使用特定的网格线确定grid item在网格内的位置。grid-column-start/grid-row-start 属性表示grid item的网格线的起始位置，grid-column-end/grid-row-end属性表示网格项的网格线的终止位置。Line: 可以是一个数字来指代相应编号的网格线，也可使用名称指代相应命名的网格线;Span: 网格项将跨越指定数量的网格轨道;Span: 网格项将跨越一些轨道，直到碰到指定命名的网格线; auto: 自动布局， 或者自动跨越， 或者跨越一个默认的轨道。 justify-self/align-self：沿着轴grid item 里的内容。 此属性对单个网格项内的内容生效。（justify沿着Y轴，align沿着X轴）； 2、Flexbox 布局相关 1. 什么是Flexbox：CSS3 引入的新的布局模式。它决定了元素如何在页面上排列，使它们能在不同的屏幕尺寸和设备下可预测地展现出来。2. 兼容情况，什么情况下不建议使用：IE10、11部分支持，低版本不支持，现代浏览器支持。整体页面布局或者完全支持就浏览器网站不建议使用。3. 基本API： 容器属性 Flex-direction：决定主轴的方向（即项目排列方向） row：主轴水平，起点在左； column：主轴垂直，起点在上； row-reverse：主轴水平，起点在右 column-reverse：主轴垂直，起点在下； Flex-wrap：默认情况下，项目排成一行，flex-wrap定义如何换行。 Wrap：换行，第一行在上； wrap-reverse：换行，第一行在下； Flex-flow: flex-direction和flex-warp的简写，默认row nowrap； justify-content：定义了项目在主轴（X轴）的对齐方式 flex-start：默认左对齐； flex-end：右对齐； center：居中 space-between：两端对齐，间隔相等; space-around：每个项目两侧间隔相等。 align-items：定义了项目在交叉轴（Y轴）上的对齐方式 Flex-start：交叉轴起点对齐； flex-end：终点对齐； center:居中 Baseline：项目第一行文字对齐； stretch：默认，未设置高度。占满容器高度。 项目属性 order： 定义项目的排列顺序，数值越小，越往前，默认0 flex-grow： 定义项目的放大比列，默认0，即如果存在剩余也不放大，如果所有项目的flex-grow属性为2，其他为1，则前者占据比其对一倍。 flex-shrink： 定义了项目的缩小比列，默认1，如果空间不足，则缩小，。如果所有项目的flex-shrink属性为1，当空间不足时，都将等比列缩放，如果一个项目的flex-shrink属性为0，其他为1，若空间不足，为0则不缩小。 flex-basis： 定义了在分配多余空间之前，项目占据的主轴空间，浏览器根据这个属性，计算主轴是否又多余空间，默认为auto，即本来大小。 flex： flex是flex-grow，flex-shrink，flex-basis的简写，默认0，1，auto； align-self： 允许单个项目有与其他项目不一样的对齐方式，可以覆盖align-items属性，默认为auto，表示继承父元素的align-items属性。 3、实现两栏布局，三列布局中间自适应，三栏布局（圣杯布局，双飞翼布局）的方法。&nbsp;&nbsp;&nbsp;&nbsp;a、两栏布局（左侧固定，右侧自适应）&nbsp;&nbsp;&nbsp;&nbsp;第一种: float + BFC方法（这个方案同样是利用了左侧浮动，但是右侧盒子通过overflow: auto;形成了BFC，因此右侧盒子不会与浮动的元素重叠。）1234567891011.wrapper&#123; overflow: auto;&#125;.wrapper .left &#123; float: left; margin-right: 20px;&#125;.wrapper .right &#123; margin-left: 0; overflow: auto;&#125; &nbsp;&nbsp;&nbsp;&nbsp;第二种: Flex方案12345678910111213/* flex容器的一个默认属性值:align-items: stretch;这个属性导致了列等高的效果。 *//* 为了让两个盒子高度自动，需要设置: align-items: flex-start; */wrapper&#123; display: flex; align-items: flex-start;&#125;.wrapper .left &#123; flex: 0 0 auto;&#125;.wrapper .right &#123; flex: 1 1 auto;&#125; &nbsp;&nbsp;&nbsp;&nbsp;b、三列布局（左右宽度固定（要想不固定将宽度值改为百分值即可），中间自适应）&nbsp;&nbsp;&nbsp;&nbsp;第一种：绝对定位法（左右两栏采用绝对定位，分别固定于页面的左右两侧，中间的主体栏用左右margin值撑开距离。于是实现了三栏自适应布局。）注：html元素高度为100%；&nbsp;&nbsp;&nbsp;&nbsp;第二种：自身浮动法（左栏左浮动，右栏右浮动，主体直接放后面，就实现了自适应）;&nbsp;&nbsp;&nbsp;&nbsp;第三种：圣杯布局（中间栏要在浏览器中优先展示渲染）&nbsp;&nbsp;&nbsp;&nbsp;实现思路：首先设置父元素位置，padding左右空出left和right的宽度，将主体部分的三个子元素都设置左浮动，设置main宽度width：100%；让其独占一行，然后设置left和right的负的外边距（负的margin-left会让元素沿文档流向左移动，如果负的数值比较大就会一直移动到上一行，设置left部分的margin-left为-100%,就会使left向左移动一整个行的宽度，由于left左边是父元素的边框，所以left继续跳到上一行左移，一直移动到上一行的开头，并覆盖了main部分，left上移过后，right就会处于上一行的开头位置，这时再设置right部分margin-left为负的宽度，right就会左移到上一行的末尾。）接下来分别把left和right用相对定位移动到两个留白就可以。代码如下123456&lt;!--html--&gt;&lt;div class='container'&gt; &lt;div class='main'&gt;main&lt;/div&gt; &lt;div class='left'&gt;left&lt;/div&gt; &lt;div class='right'&gt;right&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425/* css */.container&#123; padding: 0 300px 0 200px;&#125;.left,.main,.right&#123; position: relative; min-height: 130px; float: left;&#125;.left&#123; left: -200px; margin-left: -100%; background: green; width: 200px;&#125;.right&#123; right: -300px; margin-left: -300px; background-color: red; width: 200px;&#125;.mian&#123; background-color: blue; width: 100%;&#125; &nbsp;&nbsp;&nbsp;&nbsp;第四种：双飞翼布局（与圣杯布局的不同在于解决中间栏div内容不被遮挡问题）12345678&lt;!--html--&gt;&lt;div class='container'&gt; &lt;div class='main'&gt; &lt;div class='content'&gt;main&lt;/div&gt; &lt;/div&gt; &lt;div class='left'&gt;left&lt;/div&gt; &lt;div class='right'&gt;right&lt;/div&gt;&lt;/div&gt; 1234567891011121314151617181920212223/* css 双飞翼布局比圣杯布局多创建了一个div，但不用相对布局了。*/.left,.main,.right&#123; float: left; min-height: 130px; text-align: center;&#125;.left&#123; background: green; width: 200px; margin-left: -100%;&#125;.mian&#123; background-color: blue; width: 100%;&#125;.right&#123; background-color: red; width: 200px; margin-left: -300px;&#125;.content&#123; margin:0 300px 0 200px;&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结(二) Css基础篇]]></title>
    <url>%2Fposts%2FsummaryCss1%2F</url>
    <content type="text"><![CDATA[一、简单介绍&nbsp;&nbsp;&nbsp;&nbsp;Css基础的东西比较多，涉及到基础问题也比较多，例如盒模型，布局，Css3，Sass的一些基础内容，Css部分打算分三块去写，一章是Css相关的特性，然后把布局部分单独拿出来一章来写，Sass部分和Css3部分拿出来一章来写，暂时计划是这样，如果后面东西比较多的话在适当增加些篇幅。 二、Css基础相关1、 盒模型，box-sizing&nbsp;&nbsp;&nbsp;&nbsp;box-sizing 属性用于改变元素相对于其“盒模型”的大小的方式&nbsp;&nbsp;&nbsp;&nbsp; API： content-box（默认），border-box，inherit，padding-box（已从规范移除）&nbsp;&nbsp;&nbsp;&nbsp;简单理解就是当box-sizing为默认时，为元素设置width，Height是不包括border和padding宽度，设置为border-box，width实质等于border + padding + content，当创建流体（flow）和网格（grid）布局时，例如，你需要计算列的宽度时，这是特别有用的。而不必担心额外的 padding 和 border 宽度会破坏布局，使创建布局更容易。 2、CSS实现隐藏页面的方式 1、Display：none （真正隐藏元素，不占据任何空间，不生成盒模型） 2、Opacity设置为0 （视觉上隐藏，元素本身仍然占有位置，仍然响应用户操作） 3、Visibility：hidden （视觉上隐藏，仍然对布局起作用，不会响应用户操作） 4、Position{absolute，top：-9999，left：-9999} （既想要交互，又不想影响布局时） 3、如何实现水平居中和垂直居中。123// 简单水平居中：margin:0 auto;text-align:center; 123// 简单垂直居中height:line-height;vertical-align:middle; 1234567891011121314151617181920212223// 复杂div居中,第一种 （IE9(-ms-), IE10+以及其他现代浏览器）parentElement&#123; position:relative;&#125;childElement&#123; position: absolute; top: 50%; transform: translateY(-50%);&#125;// 复杂div居中,第二种 (IE8+以及其他浏览器)parentElement &#123; position: relative;&#125;childElement &#123; position: absolute; left: 0; top: 0; right: 0; bottom: 0; margin: auto;&#125;// 复杂div居中,第三种 Flex 布局：(不考虑兼容老式浏览器)parentElement&#123; display:flex; /*Flex布局*/ display: -webkit-flex; /* Safari */ align-items:center; /*指定垂直居中*/&#125; 4.元素浮动后的display值无论当前元素为块级元素`block`或者行内元素`inline`或者`inline-block`，被设置为浮动后，元素的`display`属性都变为`block`。 5、浮动元素引起的问题和解决办法问题： 1.父元素的高度无法被撑开，影响与父元素同级的元素 2.与浮动元素同级的非浮动元素会跟随其后 3.若非第一个元素浮动，则该元素之前的元素也需要浮动，否则会影响页面显示的结构 解决：清除浮动。1234567891011// 清除浮动常用方法// 1、clear: both// 2、封装通用类名clearfix:after&#123; content:"."; display:block; height:0; visibility:hidden; clear:both;&#125;.clearfix &#123; *zoom:1;&#125; 6、link和@import引入css的区别 区别1：link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务; @import属于CSS范畴，只能加载CSS。区别2：link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。区别3：link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。区别4：ink支持使用Javascript控制DOM去改变样式；而@import不支持。 7、有哪些常用块级元素，行内元素，block、inline和inline-block的区别&nbsp;&nbsp;&nbsp;&nbsp;常见的块级元素有 div, form, table, p, H1~H6, dl, ol, ul等。&nbsp;&nbsp;&nbsp;&nbsp;常见的内联元素有 span, a, em, label, input, select, textarea, img等。&nbsp;&nbsp;&nbsp;&nbsp;Block: 会独占一行,可以设置width,height属性。即使设置了宽度,仍然是独占一行. 可以设置margin和padding属性。&nbsp;&nbsp;&nbsp;&nbsp;Inline: 不会独占一行，多个相邻的行内元素会排列在同一行里，直到一行排列不下，才会新换一行，其宽度随元素的内容而变化, 设置width,height属性无效, 水平方向的padding-left, padding-right, margin-left, margin-right都产生边距效果；但竖直方向的padding-top, padding-bottom, margin-top, margin-bottom不会产生边距效果。&nbsp;&nbsp;&nbsp;&nbsp;Inline-block：将对象呈现为inline对象，但是对象的内容作为block对象呈现。之后的内联对象会被排列在同一行内, 使其既具有block的宽度高度特性又具有inline的同行特性。 8、css dpi(每英寸包含点的数量（dots per inch）)普通屏幕通常包含96dpi，一般将2倍于此的屏幕称之为高分屏，即大于等于192dpi的屏幕，比如Mac视网膜屏就达到了192dpi（即2dppx），打印时一般会需要更大的dpi； 9、Attribute与property的区别&nbsp;&nbsp;&nbsp;&nbsp;property是DOM中的属性，是JavaScript里的对象；attribute是HTML标签上的特性，它的值只能够是字符串；property能够从attribute中得到同步；attribute不会同步property上的值；attribute和property之间的数据绑定是单向的，attribute-&gt;property；更改property和attribute上的任意值，都会将更新反映到HTML页面中； 10、流式布局，自适应布局，响应式布局&nbsp;&nbsp;&nbsp;&nbsp;流式布局（Liquid Layout）：页面元素的宽度按照屏幕分辨率进行适配调整，但整体布局不变。代表作栅栏系统（网格系统）。&nbsp;&nbsp;&nbsp;&nbsp;布局特点和设计方法：屏幕分辨率变化时，页面里元素的大小会变化而但布局不变。使用%百分比定义宽度，高度大都是用px来固定住，可以根据可视区域 (viewport) 和父元素的实时尺寸进行调整，尽可能的适应各种分辨率。往往配合 max-width/min-width 等属性控制尺寸流动范围以免过大或者过小影响阅读。&nbsp;&nbsp;&nbsp;&nbsp;自适应布局（Adaptive Layout）：自适应布局的特点是分别为不同的屏幕分辨率定义布局，即创建多个静态布局，每个静态布局对应一个屏幕分辨率范围。&nbsp;&nbsp;&nbsp;&nbsp;布局特点和设计方法：屏幕分辨率变化时，页面里面元素的位置会变化而大小不会变化。 使用 @media 媒体查询给不同尺寸和介质的设备切换不同的样式。在优秀的响应范围设计下可以给适配范围内的设备最好的体验，在同一个设备下实际还是固定的布局。&nbsp;&nbsp;&nbsp;&nbsp;响应式布局（Responsive Layout）：分别为不同的屏幕分辨率定义布局，同时，在每个布局中，应用流式布局的理念，即页面元素宽度随着窗口调整而自动适配。&nbsp;&nbsp;&nbsp;&nbsp;布局特点和设计方法：每个屏幕分辨率下面会有一个布局样式，即元素位置和大小都会变。媒体查询+流式布局。通常使用 @media 媒体查询 和网格系统 (Grid System) 配合相对布局单位进行布局，实际上就是综合响应式、流动等上述技术通过 CSS 给单一网页不同设备返回不同样式的技术统称。 11、移动端布局方案 JS + rem 淘宝Flexible 12、 BFC（block formatting context）块格式化上下文相关BFC可以理解为没有定义，但有一些特性/功能。例如BFC包住浮动元素，或float + div做左右自适应布局。 CSS3中display：flow-root；就是创建一个BFC； 触发BFC： body 根元素； 浮动元素：float 除 none 以外的值 绝对定位元素：position (absolute、fixed)； display 为 inline-block、table-cells、flex、flow-root； overflow 除了 visible 以外的值 (hidden、auto、scroll)BFC特性及应用 同一个 BFC 下外边距会发生折叠，如果想要避免外边距的重叠，可以将其放在不同的 BFC 容器中。 BFC 可以包含浮动的元素（清除浮动） BFC 可以阻止元素被浮动元素覆盖，可以用来实现两列自适应布局。 13、清除浮动的原理在支持BFC的浏览器（IE8+，firefox，chrome，safari）通过创建新的BFC闭合浮动； 在不支持BFC的浏览器 （IE6-7），通过触发 hasLayout 闭合浮动。 14、overflow:hidden有什么缺点？内容增多时候容易造成不会自动换行导致内容被隐藏掉，无法显示需要溢出的元素； 15、padding百分比是相对于父级宽度还是自身的宽度相对于父级宽度； 16、移动端开发用JavaScript 正则表达式判断平台。123456789101112var u = navigator.userAgent, app = navigator.appVersion;//移动终端浏览器版本信息trident: u.indexOf("Trident") &gt; -1, //IE内核presto: u.indexOf("Presto") &gt; -1, //opera内核webKit: u.indexOf("AppleWebKit") &gt; -1, //苹果、谷歌内核gecko: u.indexOf("Gecko") &gt; -1 &amp;&amp; u.indexOf("KHTML") == -1, //火狐内核mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端android: u.indexOf("Android") &gt; -1 || u.indexOf("Linux") &gt; -1, //android终端或者uc浏览器iPhone: u.indexOf("iPhone") &gt; -1 , //是否为iPhone或者QQHD浏览器iPad: u.indexOf("iPad") &gt; -1, //是否iPadwebApp: u.indexOf("Safari") == -1 //是否web应该程序，没有头部与底部 17、CSS 选择器的优先级 优先级顺序 内联样式 &gt; ID选择器 &gt; 伪类 &gt; 属性选择器 &gt; 类选择器 &gt; 元素（类型）选择器 &gt; 通用选择器 选择器优先权，规则 内联样式表的权值最高 1000。ID 选择器的权值为 100。Class 类选择器的权值为 10。 HTML 标签（类型）选择器的权值为 1。 选择器都有一个权值，权值越大越优先。当权值相等时，后出现的样式表设置要优于先出现的样式表设置。创作者的规则高于浏览者：即网页编写者设置的CSS 样式的优先权高于浏览器所设置的样式。继承的CSS 样式不如后来指定的CSS 样式，在同一组属性设置中标有“!important”规则的优先级最大。 18.CSS中的长度单位（em, rem, pt, ex,vw,vh,vmin,vmax）&nbsp;&nbsp;&nbsp;&nbsp;em： 相对单位，基准点为父节点字体的大小，如果自身定义了font-size按自身来计算&nbsp;&nbsp;&nbsp;&nbsp;rem： 相对单位，可理解为”root em”,相对根节点html的字体来计算。chrome最小字体为12号，即使设置10px也会显示成12px，把html的font-size设置成10px,rem还12px为基准，页面基准320px(20px),html font-size值的计算：1234// 参考手淘var ele = document.getElementsByTagName("html")[0]; size = document.body.clientWidth/320*20; ele.style.fontSize = size + "px"; &nbsp;&nbsp;&nbsp;&nbsp;pt: point，大约1/72寸&nbsp;&nbsp;&nbsp;&nbsp;ex: 取当前作用效果的字体的x的高度，在无法确定x高度的情况下以0.5em计算(IE11及以下均不支持，firefox/chrome/safari/opera/ios safari/android browser4.4+等均需属性加么有前缀)&nbsp;&nbsp;&nbsp;&nbsp;vw： viewpoint width，视窗宽度，1vw等于视窗宽度的1%。&nbsp;&nbsp;&nbsp;&nbsp;vh： viewpoint height，视窗高度，1vh等于视窗高度的1%。&nbsp;&nbsp;&nbsp;&nbsp;vmin： vw和vh中较小的那个。&nbsp;&nbsp;&nbsp;&nbsp;vmax： vw和vh中较大的那个。 19、雪碧图将小图标合并到一张图片上，然后利用css的背景定位（background-position）来显示需要显示的图片部分，从而减少你的网站的HTTP请求数量。 优点：减少加载图片对服务器请求次数，提高页面的加载速度，减少鼠标滑过的一些bug。 缺点：内存使用，影响浏览器的缩放功能，拼图维护比较麻烦，使CSS的编写变得困难。 20.常遇到的浏览器兼容性问题有哪些？常用的hack的技巧 1：表单元素行高不一致解决方案： 给表单元素添加float：left（左浮动）；或vertical-align：middle；2：当在a标签中嵌套img标签时，在某些浏览器中img会有蓝色边框；解决方案： 给img添加border：0；或者是border：none；]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端知识点总结(一) Html篇]]></title>
    <url>%2Fposts%2FsummaryHtml%2F</url>
    <content type="text"><![CDATA[一、初衷&nbsp;&nbsp;&nbsp;&nbsp;时光飞逝，转眼还有两个多月19年就过去了，最近打算更新一系列自己整理的关于前端知识点的一些汇总，算是对自己掌握知识的一个汇总，查漏补缺，系列打算分为四个大块来梳理，大概分为HTML部分、Css部分(包括Sass用法)、Js部分(包括ES6相关基础)、最后拓展部分总结一些关于常用的方法或者概念梳理。此系列文章纯粹属于温故知新，大部分都是基础的知识，如有整理的不到位之处，望各位轻拍。 二、HTML1、 HTML5 新特性，语义化 Section： 定义文档中的主体部分的节、段 Article： 定义来自外部的一个独立的、完整的内容块，例如什么论坛的文章 Header： 定义文档、页面的页眉。通常是一些引导和导航信息 Footer： 定义了文档、页面的页脚 Nav： 定义了一个链接组成的导航部分 Progress： 进度条（value，max） Summary，details 定义元素，用户可以点击查看或者隐藏: Datalist: 定义可选数据的列表，与 input 配合使用 2、浏览器的标准模式和怪异模式（quirks mode）&nbsp;&nbsp;&nbsp;&nbsp;由来：由于历史的原因，在W3C标准出台前不同浏览器对页面的渲染是不同的。&nbsp;&nbsp;&nbsp;&nbsp;区别： a、严格模式，width 是内容宽度，元素真正宽度 = margin + border + padding + width;怪异模式，width 是元素实际宽度，内容宽度 = width - padding - border。 b、标准模式下给span等行内元素设置width和height不会生效，而在怪异模式下会生效。 c、在标准模式下，一个元素的高度是由其包含的内容决定的，如果父元素没有设置高度，子元素设置一个百分比的高度是无效的。 d、怪异模式下margin：0 auto，水平居中失效，需用text-align：center。 3、xhtml和html的区别 XHTML 元素必须被正确地嵌套。 XHTML 元素必须被关闭。 XHTML 标签名必须用小写字母。 XHTML 文档必须拥有根元素。 4、使用data-的好处&nbsp;&nbsp;&nbsp;&nbsp;赋予我们在所有 HTML 元素上嵌入自定义 data 属性的能力，用于存储页面或应用程序的私有自定义数据，以创建更好的用户体验（不进行 Ajax 调用或服务器端数据库查询）。 5、meta标签&nbsp;&nbsp;&nbsp;&nbsp;提供有关页面的元信息(meta-information)，比如针对搜索引擎和更新频度的描述和关键词。 6、Canvas&nbsp;&nbsp;&nbsp;&nbsp; &lt;canvas&gt; 标签定义图形，比如图表和其他图像，但必须使用脚本（js）来绘制图形。首先需要获取canvas对象，创建context对象，getContext(&quot;2d&quot;) 对象是内建的 HTML5 对象，拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法.下面是canvas的API简单介绍：&nbsp;&nbsp;&nbsp;&nbsp; a、Canvas坐标: (canvas是一个二维网格，左上角坐标为0，0)：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FillRect（x,y,width,height）： 在画布上绘制width*height的矩形，从左上角（x，y）开始。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;FillStyle： 可以是CSS颜色，渐变，图案默认是#000（黑色）。&nbsp;&nbsp;&nbsp;&nbsp; b、Canvas路径: (绘制线条必须使用ink方法例如stroke()，fill() )&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;moveTo(x,y)： 定义线条开始坐标&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lineTo(x,y)： 定义线条结束坐标&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lineTo(x,y)： 起点坐标，半径，开始位置，结束位置&nbsp;&nbsp;&nbsp;&nbsp; c、Canvas文本：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Font：定义字体&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;fillText：（text，x，y）在canvas上绘制实心的文本（文字，文字起点位置）&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;strokeText：（text，x，y）在canvas上绘制空心的文本&nbsp;&nbsp;&nbsp;&nbsp; d、Canvas渐变：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createLinearGradient(x，y，x1，y1) 创建线条渐变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;createRadialGradient (x，y，r，x1，y1，r1) 创建一个径向/圆渐变&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;addColorStop：方法指定颜色停止，参数使用坐标来描述，可以是0至1.&nbsp;&nbsp;&nbsp;&nbsp; e、Canvas图像：&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;drawImage(image,x,y)：将图像放在画布上 7、HTML废弃的标签&nbsp;&nbsp;&nbsp;&nbsp;font: 可以通过size属性改字体大小,还可以用color属性改变颜色； b : 可以加粗文字 u : 可以加下划线 i : 倾斜； del : 删除线 hr : 水平线；strong : 强调 em : 强调 8、IE6/7/8 bug，及兼容写法 1、IE6 css选择器不支持子选择器 2、在IE浏览器中，定位元素的z-index层级是相对于各自的父级容器，所以会导致z-index出现错误的表现。解决方法：其父级元素定义z-index，有些情况下还需要定义position:relative； 9、css js放置位置和原因&nbsp;&nbsp;&nbsp;&nbsp;js是阻塞加载，会影响页面加载的速度，如果js文件比较大，算法也比较复杂的话，影响更大。CSS放在前端是页面渲染时首先是根据DOM结构生成一个DOM树然后加上CSS样式生成一个渲染树，如果CSS放在后面可能页面会出现闪跳的感觉，或者是白屏或者布局混乱样式很丑直到CSS加载完成。 10、什么是渐进式渲染&nbsp;&nbsp;&nbsp;&nbsp;以往基于字符串拼接的模板引擎技术, 性能可以,前端不方便,而现在基于 Virtual DOM 实现的后端渲染, 前端舒服, 后端却变慢,原因是 Virtual DOM 难以做静态分析进行预编译, 最终难以提高性能.另外组件级别 Caching(缓存) 方案也不够成熟, 提高性能短期做不到, 那么考虑对服务端渲染的工作进行缩减.比如说, 首屏渲染多少内容? 整页渲染性能低, 能不能只渲染部分,比如说只渲染第一屏主体内容, 而下方或者更详细数据在客户端抓取.就是说, 服务端渲染一部分, 客户端加载一部分, 从而做出效果。 11、html模板语言&nbsp;&nbsp;&nbsp;&nbsp;html有打开效率高的先天优势，但也有一个先天缺陷“不支持动态语言”，这也是html模板语言出现的原因，让网站即享受html高效，又享受内容的动态化；使用比较多的模板引擎也就是Handlebars.js，Etpl，基本原理也就是将json数据通过一些方法，例如用对应的字符串匹配替换扩展方法（正则匹配），转换成html模板片段，然后一个实际的javascript循环。 12、meta viewport简介1&lt;meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1, maximum-scale=1, user-scalable=no"&gt; width： 控制 viewport 的大小，可以指定值，还可以特殊的值，如：device-width。 height： 与 width 相对应，指定viewport 高度。 initial-scale： 初始缩放比例，也即是当页面第一次 load 的时候缩放比例。 maximum-scale： 允许用户缩放到的最大比例。minimum-scale：允许用户缩放到的最小比例。 user-scalable： 是否允许用户手动缩放。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Git的基本操作和 git workflow]]></title>
    <url>%2Fposts%2FgitWorkflow%2F</url>
    <content type="text"><![CDATA[一、扯扯Git的诞生&nbsp;&nbsp;&nbsp;&nbsp;在没有Git之前，大家大部分都是靠SVN和CVS等集中式的版本控制系统，集中式版本控制系统不但速度慢，而且必须联网才能使用，所有的版本信息都放在服务器上，万一服务器宕机一个小时，基本上这一个小时大家就不用工作了。这个时候分布式代码版本控制就横空出世了，优点很明显，分布式管理，没有网络的情况下仍然可以查看日志、提交代码、创建分支，而且支持local branch, 缺点可能算是有一定的学习曲线，但是作为程序员算是一个基本技能。 二、Git的基本操作1、创建版本库&nbsp;&nbsp;&nbsp;&nbsp;版本库其实就是一个仓库，仓库里面的所有文件都可以被Git管理起来，对文件的每次修改，删除，新增都可以进行追踪。新建一个仓库非常简单只需要新增一个文件夹，然后init一下就可以。12345// 新建一个文件夹$ mkdir gitDemo// 初始化Git仓库$ git init &nbsp;&nbsp;&nbsp;&nbsp;然后你就会发现在文件夹下多了一个.git的文件夹，这个文件夹就是来跟踪管理版本库的，一般不需要改动。如果没有看到.git文件夹那应该是隐藏了可以通过 ls -ah 命令查看。 2、将文件添加到版本库&nbsp;&nbsp;&nbsp;&nbsp;当我们对文件进行改动需要提交到仓库时，只需要做二步就可以,假如我需要把readme.text加入到仓库123456// 用 add 命令告诉 git 我准备把文件添加到仓库, 暂时先放在你这(暂存区)$ git add readme.text// 用 commit 命令提交到本地仓库，Git是分布式，commit后本地就会有提交记录// commit命令是有一个 -m 参数后面跟随的是此次提交的说明，这个说明很重要，不能乱写，不然后面找改动记录就很麻烦了$ git commit -m 'init readme.text file' &nbsp;&nbsp;&nbsp;&nbsp;我们现在已经成功提交了一个文件，如果我们想随时知道当前版本库的状态可以使用 git status 命令进行查看，这个命令会告诉我们当前的状态几个文件add, 几个commit都可以清楚的看到，但是如果我们想知道这次对文件做了哪些修改，就可以使用 git diff命令进行查看，这个命令在我们实际开发中每次提交前通过diff去查看本次的改动还是很有必要的。 3、远程仓库&nbsp;&nbsp;&nbsp;&nbsp;我们知道一个项目不可能只有我们自己在开发，那么协作开发就需要用到一个中间服务器，角色有点类似SVN的中央存储但是又有本质的区别，在git中可以理解成交换中心，我们自己写完代码推送到远程交换中心，别人想要看到我们的最新代码就需要就远程就拉取。远程库的创建有两种方式，一种是本地已有仓库，和远程关联，一种是先创建远程，直接通过命令克隆到本地然后进行开发。如果一个项目从头开始，个人还是比较建议先创建远程仓库，然后从远程克隆库。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I、添加远程库&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;假设我们现在已经创建了一个远程仓库，现在流行的git仓库管理地址也就差不多是Github Gitee GitLab等平台，创建仓库的方式都大同小异也很简单。创建仓库后会提示我们克隆新的，还是关联已有的，如果关联已有的话我们需要在本地仓库运行命令：1$ git remote add origin git@github.com:userName/gitDemo.git &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;以 GitHub 为例，上面的userName需要替换成你自己的账户名称，这个命令其实就是将本地仓库和远程关联了起来，下一步就需要把本地的内容全部推送上去。1$ git push -u origin master &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git push命令就是把本地库的内容推送到远程，由于远程库是空的，我们第一次推送master分支时，加上了-u参数，Git不但会把本地的master分支内容推送的远程新的master分支，还会把本地的master分支和远程的master分支关联起来，在以后的推送或者拉取时就可以简化命令。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;II、从远程克隆&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;从远程克隆的话其实就很简单了，远端创建好仓库后，只需要执行命令：1$ git clone git@github.com:userName/gitDemo.git &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;如果有多人开发只需要每个人各自克隆一下就好了。 4、分支管理&nbsp;&nbsp;&nbsp;&nbsp;几乎每一种版本控制系统都以某种形式支持分支，分支的功能大致就是将不同功能的代码剥离出来，同时不影响主线的开发。实际应用中，一般采用一个master主分支，为线上稳定版本分支，此分支不可直接提交，只能通过develop或者hotfix分支进行合并。一个为develop开发分支，分支为最新完成开发通过开发自测的开发分支，在我们项目中，给到测试的代码就是直接从develop中打包，而没有采用release分支。第三个为feature分支，也就是功能分支，当我们接到一个新功能需要开发时，需要从develop分支切一个属于自己的功能开发分支，当功能开发完成需要交付测试时，将代码合并至develop分支。最后还需要一个hotfix分支，此分支用来解决线上爆出的bug需要紧急修复，此分支需要从线上版本master分支切出，通过测试上线后合并至master和develop分支。这是现在大多数包括我们自己开发团队在使用的Git分支管理规范和流程，也是前人经过探索总结的，来保证开发过程更好的进行沟通协作。这种git flow模式下的项目会一直保留两个长期分支，master存放对外发布的稳定版，develop存放日常开发的最新版。另外master每次发布后需要对当前节点打上标签(Tag)进行记录，一般可以用于版本号记录，方便以后版本追溯。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I、基本管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;创建分支很简单,速度也很快，主要因为创建分支时，Git只是新建了一个指针，指向切出分支相同的那次提交，再把HEAD指向新分支，就表示在新建分支上，工作区文件实质上没有变化。分支操作的基础命令如下:12345678910111213141516171819// 创建分支$ git branch (branchname)// 切换分支（-b 参数表示创建并切换）// 或者 git switch （-c 参数表示创建并切换）$ git checkout (branchname)$ git checkout -b (branchname)$ git switch (branchname)$ git switch -c (branchname)// 合并分支$ git merge// 列出所有分支$ git branch// 删除分支$ git branch -d (branchname) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;II、标签管理&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;上面我们其实也有提到针对master的每次发布进行打标签，其实标签就是来定义一个重要阶段，并希望永远记住那个时刻，比如我们版本发布了1.0版本,就可以在master的最新一次提交加上V1.0得标签。1234567891011// 创建一个带注解标签$ git tag -a v1.0// 查看所有标签$ git tag// 删除标签$ git tag -d v1.0// 对历史提交打标签$ git tag v1.0 commitID &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;需要注意的一点是标签总是与某个commit挂钩的，如果这个commit既出现在master分支又出现在dev分支那么这两个分支都是可以看到标签的。 5、Git Stash 和 Git WorkTree 场景和用法&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I、Git Stash &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;我们在开发时经常会遇到这样的场景，正在 feature 分支开发功能，线上突然出现了高优先级bug要马上解决，但是新功能才写了一半不想提交，这个时候就可以用stash命令将当前进度保存起来，然后切换至另一个分支修改bug，修改完成后切回 feature 恢复之前进度继续开发。1234567891011121314// 保存当前工作进度，可以添加save增加注释，可以多次使用$ git stash save &lt;message&gt;// 显示保存进度列表$ git stash list// 恢复最新的进度$ git stash pop// 删除一个存储进度，不指定stash_id，默认删除最新$ git stash drop [stash_id]// 删除所有存储进度$ git stash clear &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;II、Git WorkTree &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;git stash 已经可以基本上帮助我们解决多个分支切换工作的问题，但是工作中更多的时候会有需要并行开发的情况，我需要同时多开编辑器，而且更多时候因为分支不同，我有可能依赖的node_modules版本也是有差异的，但是因为我们配置ignore的原因，切换分支并不会重新安装依赖会导致打包依赖时的各种问题，git 2.6以上开始提供了worktree 功能，可以解决这样的问题。git worktree 从一个仓库中可以创建多个工作目录，方便多开编辑器并行开发。git worktree的命令只有几行非常容易记住。123456789101112// 增加新的worktree$ git worktree add [路径] [分支]// 新分支创建$ git worktree add -b [新分支名] [新路径] [从此分支创建]// eg. git worktree add -b myNewBranch ../testDir master// worktree 详细情况, 可以增加 --porcelain 选项，用来改变显示风格$ git worktree list --porcelain// 删除worktree(删除关联目录后，清除worktree信息$ git worktree prune 6、撤销和回滚&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在我们开发过程中肯定会遇到这样的场景，一、我刚把不想要的代码，点错了给commit，但是还没有push，二、线上炸了，需要还原这次代码。类似于这几种情况我们就需要用到git的撤销与回滚。&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;场景一、未push之前的所有提交操作，可以统称为撤销.123456789101112131415// 文件被修改，但是还没 add$ git checkout fileName$ git checkout .// 对多个文件执行了add，但是只想提交一部分$ git add *$ git status# 取消暂存$ git reset HEAD &lt;filename&gt;// 文件执行了add 但是不想要这些改动# 取消暂存$ git reset HEAD fileName# 撤销修改$ git checkout fileName &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;场景二、已进行push，需要回滚。12345678910111213141516171819202122// 回滚到tag标记处$ git checkout &lt;tag&gt;// 撤销指定文件到指定版本# 查看指定文件的历史版本git log &lt;filename&gt;# 回滚到指定commitIDgit checkout &lt;commitID&gt; &lt;filename&gt;// 删除最后一次远程提交#使用revert$ git revert HEAD$ git push origin master# 使用reset$ git reset --hard commitID^$ git push origin master -f#区别: revert 放弃提交但是会生成一次新的提交，reset直接重置到指定提交// 回滚某次提交# 找到要回滚的commitIDgit loggit revert commitID]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hexo Next 主题添加百度统计]]></title>
    <url>%2Fposts%2Fnext1%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;网站搭建也有了很长一段时间，以前也没怎么维护过，想起来了就写点东西，域名也买了，博客也搭了，总不能就在这长草了，还是要装修装修，今天想着虽然博客没啥浏览量但是说不准以后流量会越来越大，这个时候就要去统计博客的访问情况，比如博客的历史访问量、访问来源、访问地域等统计数据。之前用过百度统计的工具，百度账号啥的也都是现成的，这篇就简单介绍下 Hexo + Next 博客配置百度统计功能。 1、注册百度统计账号&nbsp;&nbsp;&nbsp;&nbsp;首先需要注册一个百度统计的账号，这块都很简单，注册成功后登录会进入到网站列表添加目标网站。网站添加成功后可以在管理模块选择代码获取，如图所示：&nbsp;&nbsp;&nbsp;&nbsp; 按照以往的经验，想着直接拿这段代码添加到 footer.swig文件中，或者header文件中，只需要添加到网站全部页面的head标签前就行，但是网上查了资料发现，远没有那么复杂，Next 主题对百度统计已经进行了封装优化，我们只需要将上面图片中的key值写入就可以。 2、配置next主题文件&nbsp;&nbsp;&nbsp;&nbsp; 在配置文件 themes/next/_config.yml 中，有个 baidu_analytics 字段，将百度统计中的key值配置下：12# Baidu Analytics IDbaidu_analytics: 上图中key值。 &nbsp;&nbsp;&nbsp;&nbsp; 就这么简单~ 是不是so easy，然后编译发布下就OK。 3、验证时可能遇到问题&nbsp;&nbsp;&nbsp;&nbsp; 配置成功后，我们就可以到百度统计的管理模块，点击右侧的代码安装检查&nbsp;&nbsp;&nbsp;&nbsp; 如果显示的代码安装正确那么就成功没啥问题了，大概20分钟左右就可以看到统计数据，但是我在第一次测试时，页面安装状态提示：代码未生效。我手工检测了一下，发现代码安装是正确的，但是一直提示未生效，我又在其他网页中输入http:luoruihuan.top 没有添加www进行了测试，发现提示安装正确，这就比较费解了，虽然不知道具体导致原因是啥，但是我编辑了一下网站列表中的网站首页改成了去除www的形式，就ok了，虽然不知道为啥，感觉有可能是百度统计的bug。然后就可以去主页查看报告了~，虽然现在还没啥浏览量。。。]]></content>
      <categories>
        <category>建站、爬虫、其他技术相关</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[扯扯最近读的历史]]></title>
    <url>%2Fposts%2FRecentlyReadHistory%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp; 这段时间酷爱读史，今读胡三省在《资治通鉴》注中“姜维之心,始终为汉,千载之下,炳炳如丹,陈寿、孙盛、干宝之讥皆非也。”想起当年刘禅献降后，姜维密奏，“愿陛下忍数日之辱,臣欲使社稷危而复安,日月幽而复明”，这个时候姜维已经是62岁，大大小小北伐了11次。这种执着，真的是可贵。姜维的一生，是充满矛盾的，在众生相中有些格格不入的。无论身前事，还是身后名。当年写下“若有远志，不在当归”，能在异国一片主和声坚持攻伐自己的母国，执著甚于诸葛亮。 &nbsp;&nbsp;&nbsp;&nbsp; 《银河英雄传说》中，杨威利说过一句话：“我不能选择最好的，我只是选择较好的制度。” 被诸多银英迷奉为圭臬。但可惜，这句话并不适用所有情况：“三国归晋”并不是一个相对较好的选择，而是剩下的唯一选择：短期内不那么差，长期更差。当然，封建集团出于政治目的在后世对他的褒贬，现在看来没有什么直接的参考意义。但他最后这份卫国者的决绝，值得任何人尊重。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何看待读书杂]]></title>
    <url>%2Fposts%2FReadingForComment%2F</url>
    <content type="text"><![CDATA[&nbsp;&nbsp;&nbsp;&nbsp;前段时间和同学聊天，聊到读书的问题，大学时候经常泡在图书馆看各种书，于是大家一起讨论，读书肯定是有好处的，这是毋庸置疑的，但是读了那么多的杂书，意义在哪呢，后来想了很久，印象中梁启超曾说过，“书宜杂读，业宜精钻”，今悟: 读书杂，头绪多，可以探微寻幽，别开蹊径。业务精，专一艺，可以打牢基础，扬其所长；业务精，明利弊，可以看事通透，做事到底。 &nbsp;&nbsp;&nbsp;&nbsp;挤出时间学些常识性东西，特别是文学，或人文科学，稍多用点工夫就能有大收获,以前不屑的一些东西，要试着去接触。既然我不能判断是坏的，那为什么要拒之门外呢？既然是存在的，那我就应该了解这些常识。停止学习，停止读书，我仿佛看到了未来的自己，一无所知的自己。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript三元条件运算符]]></title>
    <url>%2Fposts%2FTernaryConditionalOperator%2F</url>
    <content type="text"><![CDATA[今天谈一个小知识点，三元运算符。三元运算，顾名思义会有三个要素，表达式的大致组成为condition ? expr1 : expr2；一个语句加两个表达式。问号之前为判断语句。如果为真，则执行第一个表达式，如果为假，则执行第二个表达式。我的理解其实就是简化的if else语句，举个栗子，经常看到的一个点击展开，再点击隐藏按钮: 我想实现点击输入法，实现下面ul的展开与隐藏，如果我们用if else的话可能会这么写： 1234567 oBth.onclick=function()&#123; if (oUl.style.display=='block') &#123; oUl.style.display=='none'; &#125;else&#123; oUl.style.display=='block'; &#125;&#125; 但是如果我们用三元运算符的话可能就只需要下面这一行代码： 123 oBth.onclick=function()&#123; oUl.style.display == "block" ? oUl.style.display="none" : oUl.style.display="block"&#125; 有木有很神奇。当然我只是用了一个比较容易理解的写法，还有很大的优化空间，我们当然也可以这样： 12345oBth.onclick=function()&#123; var style = oUl.style.display; oUl.style.display= style == "block" ? "none":"block" //这样写的话就一定不能忘了把运算结果重新赋值给元素 - - //oUl.style.display= (style == "block" ? "none":"block") 可读性更高&#125; 上面代码的意思是，如果style == “block” 成立的话就把none返回，不成立就返回block，然后把返回结果赋值给作用元素，不过要特别注意 = 和 == 用法和区别。因为赋值运算符（=）的优先级比较低，所以会最后执行赋值运算。如果把后面的三元运算符加上（）可读性会更高一点，但效果是一样的。 比较容易出错的地方：三元运算比较容易出错的应该就是运算的优先级问题： 12var isMember = false;console.log("当前费用" + isMember ? "$2.00" : "$10.00"); //返回$2.00 1"当前费用false" ? "$2.00" : "$10.00"); 在js中字符串是为真的，所以会输出$2.00. 不过为了避免以上错误的话，可以记住 不是false, 0, undefined, NaN, “” or null，js都认为是true;感谢阅读。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原生js实现幻灯片轮播效果]]></title>
    <url>%2Fposts%2FJSSwiper%2F</url>
    <content type="text"><![CDATA[在以往的认知中，一直以为用原生JS写轮播是件很难得事情，今天上班仿照网上的写了一个小demo。小试牛刀。 大致效果： html结构很简单，两个列表，一个代表图片列表，一个是右下角序号列表。 12345678910111213141516&lt;div id="box"&gt; &lt;ul class="list"&gt; &lt;li&gt;&lt;img src="01.jpg" width="490" height="170" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="02.jpg" width="490" height="170" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="03.jpg" width="490" height="170" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="04.jpg" width="490" height="170" /&gt;&lt;/li&gt; &lt;li&gt;&lt;img src="05.jpg" width="490" height="170" /&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ul class="count"&gt; &lt;li class="current"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 布局的大致想法是图片全部绝对定位重合，透明度为1，右下角序号给选中的添加样式。样式都很简单。 关于JS方面，自己还是捉摸了很久，刚开始实现时，当鼠标移入右下角对应序列号时图片能够准时切换，但是鼠标移出时便不能自动播放，关于setInterval和clearInterval自己的处理还是不是很好。借鉴了网上的案列之后，具体的实现逻辑简单为，先写一个图片的展现方法，和鼠标移出图片时的定时函数。这样可以在事件中直接调用，值得注意的一点就是在鼠标移入时，记得清除定时器。下面上代码： 这是图片展示函数，参数为当前的展示的index。先让所有图片透明度为0；所有下标没有样式，然后给当前的加上样式，透明度为1；12345678function show(a)&#123; for(var i=0;i&lt;oLi.length;i++)&#123; oLi[i].style.opacity= 0; oImg[i].className = ''; &#125; oLi[a].style.opacity = 200; oImg[a].className = 'current';&#125; 然后写一个鼠标移除时的定时器，图片自动轮播函数： 12345678910function autoplay()&#123; time = setInterval(function()&#123; b++; if(b&gt;=oImg.length)&#123; b=0; &#125; show(b); &#125;,1000);&#125;autoplay();//自动运行 最后是鼠标移入移出事件: 12345678910for(var i=0;i&lt;oImg.length;i++)&#123; oImg[i].index = i; oImg[i].onmouseover=function()&#123; clearInterval(time); show(this.index) &#125; oImg[i].onmouseout=function()&#123; autoplay(); &#125;&#125; 代码只是写了一个结构骨架，实现大致效果，具体可以优化的地方还有很多，对于动效方面可以对透明度的改变设置一个函数，让透明度缓慢变成1，或者对图片的定位和移动方向进行改变，实现真正意义上的左右轮播。大致原理都是差不多的。 原生JS实现轮播，于我而言还是有点小难度的，因为JS写的比较少，所以对于整体的逻辑把握不好，虽有曲折，但是靠着自己也是写了出来。 总结一些轮播遇到的大致困难，第一个是对于鼠标移出时的定时自动轮播，刚开始自己是写在事件onmouseout里面的，但是测试过程中发现事件只会触发一次，所以导致轮播不能执行，所以选择在重新写了一个方法。第二个就是对于函数的传参问题，我写函数一直没有传参的习惯，都是匿名函数，虽然知道适用场景不同，对函数的运用应该灵活，可能是因为做的项目太少，经验还是太不足，第三个就是细节方面，例如移入时清除定时器，轮播要先执行一次等。总之收获还是很大的。 感谢阅读。]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js轮播</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[曾经的中国互联网]]></title>
    <url>%2Fposts%2FChineseInternet%2F</url>
    <content type="text"><![CDATA[1、最早在美国上市的中国互联网公司是中华网，域名牛逼，中国概念，一度股价爆高到100多美元，后来一路跌到地板，然后退市，现在，谁还记得呢。 2、曾经联想搞了一个fm365.com，联想的互联网战略，非常非常早的事情，随着联想电脑预装铺开，一度号称是国内门户前几名，然后呢？后来一度域名都丢了，然后也没有然后了。3、我们知道现在最大的文学站是起点文学，最大的下载一个是华军软件，一个是百度收购天空下载。但曾经最大的文学站黄金书屋，最大的下载站是海阔天空，然而这些网站都被一个叫多来米的公司用很低的价格收购了，那时候个人站不值钱啊，然后呢，多来米收了一堆当时最好的个人站，结果全做死了。 4、最早的电子商务网站，8848.com，曾经是中国电子商务网站头牌，在上市关键时刻的临门一脚，没有成功，然后，每况愈下。 5、世界互联网巨头收购中国互联网领先者，听上去好像是一个不错的强强联手，两个案例，ebay收购了当时的领先者易趣，彼时易趣在中国电商市场份额超过80%，然后被新成立的淘宝打的丢盔卸甲。 雅虎收购了3721，当时3721的收入规模和终端覆盖率均力压百度，然后就眼看着百度神话诞生了。 6、第一只A股上的互联网概念股叫做海虹控股，当时他们控股了中国最大的，完全独孤求败的棋牌游戏平台，联众游戏。 然后慢慢的联众就废掉了，一步步落后于时代。 今天我们不要说腾讯了，说波克城市这样的棋牌平台，收入我估计都比联众高不少。 7、曾经最大的下载工具叫做网络蚂蚁。 8、互联网泡沫破裂的时候，网易是三大门户里最脆弱的，一度股价掉到1块钱以内，丁磊炒掉了他聘用的CEO，财务出现丑闻，媒体天天给网易做退市的倒计时，大家都在幸灾乐祸，然而今天我们看，三大门户里网易转身最快，新业务拓展最成功，现在游戏市场，腾讯拿他也没办法。 9、南非电讯投资腾讯的时候，所有媒体人都觉得南非人SB，被马化腾骗了，说马化腾的估值方式完全是蒙人的，oicq用户（当时不叫QQ）都是低龄低层次用户，没有消费能力。 现在作为腾讯股东的价值和回报是南非电讯集团当前市值最大的支撑，超过其本身自营业务。。 10、曾经大家都认为中国互联网大局已定，新浪搜狐的霸主地位无可动摇，今天回头看，呵呵。 11、百度和新浪曾经撕逼过，百度那时候还是技术服务商，新浪的搜索是百度提供技术支持的，然后，新浪拖欠了百度的技术服务费，李彦宏一怒之下停了新浪的搜索接口，媒体都认为百度疯了，互联网霸主新浪分分钟捏死百度，这也是李彦宏摔电话决心自己做用户的主要原因之一。 12、曾经有一种期盼，说中国互联网啥时候能出市值超过十亿美元的巨头啊，呵呵。 13、百度上市的时候市值破百亿美元，市盈率过千，当时基本上国内所有分析师都说百度被严重高估了。 14、中国做游戏是不可能赚钱的，中国人没有人会为游戏付费，这是在2002年之前行业的共识，当时说的游戏主要是pc游戏，台湾和日本的游戏在大陆都很流行，直到盛大突然崛起，一切都变了。 15、群聊功能最早是朗玛uc推出的，市场反馈极好，当时用户发展极快，新浪见状立刻收购。那时候腾讯想做用户变现，取消了电脑注册QQ的功能，只允许手机短信验证码注册，一个注册收一块钱，结果看到朗玛uc有取代之势，立即恢复免费注册，同时推出QQ群，然后新浪这次投资基本就失败了。 16、百度推出过一个百度hi的聊天工具，还有一个百度有啊的电商平台，不过今天大部分年轻人都没听说过。 我的头像来源于是百度hi当时的气泡熊表情包，我觉得百度hi最有价值的成果就是气泡熊表情做的确实不错。 17、网景浏览器曾经被认为是一种革命，市场占有率一度在80%以上，当时网景的野心很大，想用浏览器做网络终端操作系统，市场也极为认可，股价和市值扶摇直上，很多投资者都认为网景可能是互联网时代的微软，然后微软内置了浏览器，网景告微软垄断，官司一直打，微软浏览器市场份额一直上升，然后，官司没打完，网景完了。 但有意思的是，现在，国内有360浏览器，国外的火狐，google的chrome浏览器，市场占有率都不低；为什么当时网景模式没成功，而现在第三方浏览器又都冒出来了，所以，归咎于微软垄断和捆绑，不如多思考自己的问题。 我给一个答案，网景的思路是互联网上的软件公司，而如今第三方浏览器完全是走互联网模式，做软件公司，被微软掐死是分分钟的事情。 18、2000年左右微软推搜索引擎，当时还不是bing，是MSN搜索，国内分析师近乎一致认为google要完，大家都觉得微软的技术能力很强，有钱，有资源，又能铺终端，但当时俞军老师坚持认为微软根本不懂搜索，不会冲击google，我特意翻过旧帖，从此转为俞军脑残粉。 19、吴京川老师十几年前给我讲搜索套利模式的时候，我完全没听懂，几年后我看一些新闻案例突然明白了，然后感慨市场时机过去了，直到最近我才知道，其实市场时机一直都在，只是进入门槛越来越高而已，意识到自己简直蠢的不可救药。 20、地方电信的门户网站和其附属的一些资源，社区曾经一度占据互联网流量的半壁江山，比较有名的包括上海热线，贵州信息港，碧海银沙等等。 21、网易最早就是个个人站，丁磊是中国最大的个人站长，当时丁磊要搞免费邮局，去广州电信谈合作，说不要电信出一分钱共同搭建一个邮局平台，只要电信出带宽资源。（当时流量带宽老贵老贵的，但对于电信来说成本极低），合作，然后未来广告收入大家分啥的巴拉巴拉。 当时的局长张静君一听，没听懂，但是禁不住她琢磨，不要出钱还能分钱，有这么好的事情？这里肯定藏着很大的利益，这好事不能让丁磊占了，这样，我直接买你们系统。 于是就有了163.net免费邮局，国内第一个免费邮局，用户量果然激增，因为没有其他家啊，然而做了很久，也没赚到钱，后来这个邮局被卖掉了还涉及国有资产流失啥的，张静君后来出去创业，一度被认为是互联网大佬，继续呵呵吧。 当然，丁磊也够坏的，卖了163.net给电信，自己掖着163.com。 22、腾讯最早域名是tencent.com，百度 cdn 长期有个跳转域名叫做shifen.com 大家都是1毛， 这事哪说理去。 美国的巨头叫做微软，中国的巨头叫做1毛。 23、李彦宏，周鸿祎，马化腾，雷军，丁磊，史玉柱，最早都是程序员，而且都还是水平相当不错的程序员，当然更不用说张志东这样的了。其实这个名单可以拉很长，很多名气没那么大的上市公司老板其实也做过程序员，比如携程老板梁建章等等。 24、个人网站 南杨北高曾经是个人网站最早的传奇，高春辉的个人主页曾经是国内网站综合排名前十，汽车销售员出身的第一代站长杨震霆目前已经移民加拿大，当地华人没有几个知道他曾经辉煌的历史；而高春辉依然在连续创业，中国互联网草根创业者的活化石。 可能很少人知道，卓越网的第一任老板是高春辉，而那时候卓越网，是一个下载站。躲在梅州几乎从不出远门，从不接受采访以及从不参加各种峰会（实际上，只参加过一次）的中专生李兴平 创造了草根网站最大的奇迹，他依靠本地的几个人的小团队，先后创建过三个曾经位居国内访问量前20的网站，hao123, qq163 和 4399。而其他诸如3533，ip138，oicq88等一堆网站也都各个流量不菲，最疯狂的时候，一个音乐个人站长，和李兴平私交不错，就能轻松从他那里获得每天十几万到几十万的访问来路。 当然，今天，个人站长的时代过去了。 25、关于拥抱变化 百度最早是给门户做搜索技术服务商，没打算自己做流量入口； 腾讯最早想给电信做网络寻呼系统，没打算自己做用户，当时想发展点用户做样本测试系统；结果电信不鸟他，幸亏电信不鸟他。 阿里最开始做企业黄页； 盛大最开始做社区，失败了后用最后剩下的钱代理了传奇，当时大家都觉得中国游戏没市场，所以代理金极低； 京东最开始中关村摆摊的不解释； 唯品会开始搞奢侈品赔的一塌糊涂，转入二线品牌开始翻身； 聚美优品陈欧第一次创业是做游戏广告平台，然后转型卖了化妆品； 奇虎最开始做社区搜索，恶心阿里搞了360去弄死3721，没想到无心栽柳； 新浪最开始是四通利方论坛，收了海外一个华人门户后转型做门户，然后靠微博翻身； 网易从虚拟社区到邮局到门户到移动SP到游戏； 搜狐从门户到游戏； 现在你告诉我你看准了一个大方向保证未来很有前途？？ 你可以当八卦看，也可以多想想，沧海桑田的背后，为什么。然后想想，未来会怎样？我们是不是还会看走眼，选错路？]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是运营商的‘管道化危机’？ -读移动帝国整理]]></title>
    <url>%2Fposts%2FPipelineCrisis%2F</url>
    <content type="text"><![CDATA[运营商相当于高速公路，建好物理网络后对上面运营的服务进行收费。 随着手机上网速度的加快，微信、Q Q、微博等涉及语音、文字信息的服务也快速发展，这些服务占用了高速公路的车道资源，却没给收费站带来应有的收益，同时还冲击到了运营商的语音、短信、彩信等业务。移动互联网时代的到来，已经成为运营商们心中最大的煎熬。一方面，它们希望借此继续转型，在传统话音业务增长见顶的情况下，从数据业务获得更多的收入。 另一方面，在和新兴移动互联网企业同台竞争时，“基因”的差异又使得运营商们稍显力不从心。 所以各国电信业务运营商迫切的需要去‘管道化’！]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[读《雷军-从金山到小米手机》有感]]></title>
    <url>%2Fposts%2Fxiaomi%2F</url>
    <content type="text"><![CDATA[花了两天时间，读完了褚亚玲的这本《雷军-从金山到小米》。刚读完时，内心的第一反应竟是，不容易，雷军不容易。 印象中第一次接触小米是在12年刚上大一时，那时有同学用小米手机，说是为发烧而生，遂让我有了对小米的好奇和关注。而了解雷军，是在13年的赢在中国节目上，看他言谈举止，觉得这个人很有内涵，很有想法。 以上的了解都很局限，可以说是表象。前几天小米note 3发布，雷军在发布会现场落泪，引发了我的思考，我一直在想那么成功的一个企业家，面对自己打造的产品，在发布会落泪，这应该是一种怎样的情感，带着很多疑问和不解，我买了一本关于雷军的书，希望能深入的了解一下。 读完整本书，对雷军个人的崇拜和景仰有上升了一个新的高度，从大学时期的佼佼者，到金山的第六号员工，再到CEO，董事长，金山十六年，不是一般人可以比拟的。雷军是个很有毅力的人，说是毅力，倒不如说是梦想，书中有一句话，我深表同意，那就是‘没有梦想的人，永远不知道梦想的力量’。我能体会到他那时的感受和想法。不过，我还是感觉雷军的成功来的有点迟，但幸好还是来了。 1999年，在中国互联网史上，真的是值得大书特书的一年。在这一年，马云从北京返回杭州，和他的十八罗汉，创办了一家叫阿里巴巴的电子商务网站；2月，年仅28岁的马化腾开始推广一款名为OICQ的即时通信网络工具，这只叫QQ的小企鹅，在不久后便出现在中国千家万户互联网用户的电脑桌面上；6月，沈南鹏、梁建章、季琦、范敏四个好朋友聚在一起，创建了一家提供在线旅游服务的网站——携程网；7月，中华网上市，IPO当日大涨，11月，个体书商李国庆和妻子俞渝，创办了从事网络图书销售的当当网；也是在11月，董事长秘书陈天桥拒绝了即将到手的分房，下海创办了一家叫盛大的互联网游戏公司，也是这年，李彦宏认定环境成熟，启程回国，在北大资源宾馆租了两间房，开始了创建百度公司。雷军曾说，‘站在风口，一头猪都能飞起来，一个智慧的人要懂得顺势而为，不要做逆天的事情。99年是互联网最黄金的一年，错过了99，几乎没有哪个企业能够大成。但他却把盐碱地里的金山种出了草，不得不说，雷军经受的考验不一般。 从刚开始对创业的反思：在年轻人扬帆出海之际，遭遇狂风巨浪，会打击自信心，筹备成熟再出手，经过岁月沉淀之后的从容淡定，会让创业者更加游刃有余。到后来对自己的反思：聪明者不在于不走弯路与错路，而是少走弯路与错路，特别是走了弯路与错路后懂得及时回头。可以看出，雷军的每一个反思，都让自己的内心和意志更上了一层楼。雷军善于总结，善于思考，这也是最应该学习的地方。方向如果错了，走得越快，离终点越远。 有些人生下来就是要成功的，有些人，命里就有不服输的基因。从大学的积累，到在金山的历练，最后用小米实现梦想，雷军给我诠释了什么是厚积薄发，什么是信念和理想。小米会成功的，不因为别的，就因为他的boss是雷军。 最后，Google十戒，与各位共勉。 1.一切以用户为中心，其他一切纷至沓来。（Focus on the user and all else will follow）. 2.把一件事情做到极致。（It`s best to do one thing really,really well）. 3.快比慢好（Fast is better than slow）. 4.网络社会需要民主。（Democracy on the web works） 5.你不一定要在桌子上找答案。（You don`t need to be at your desk to need an answer） 6.不做坏事也能挣钱。（You can make money without doing evil） 7.未知的事情总是存在（There`s always more information out there） 8.对信息的需求无所不在。（The need for information crosses all borders） 9.不穿西装也可以严肃认真（You can be serious without a suit） 10.仅有优秀是远远不够的。（Great just isn`t good enough?）]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>读书有感</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[浅谈农村文化变迁]]></title>
    <url>%2Fposts%2FRuralCultural%2F</url>
    <content type="text"><![CDATA[依稀记得小时候观看农村“唱大戏”的场景，在农村，无论喜事还是丧事都有请戏班唱戏的风俗。本就是图个热闹吉利，或许人们观赏的仅仅局限于形式，也就渐渐助长了农村文化低俗，奢靡之风。 总是习惯于晚饭后，逢邻里乡亲有红、白事时，端一小板凳，携家带口，安坐于戏台旁。静候一场‘晚宴’。 印象中的人，总是不太多的。想想还不懂事时，总是喜欢穿梭与幕后台下，无所顾忌。那是的一切所说不上多么有档次，但极尽欢乐。 近两年，由于在外地上学，唯有适逢寒暑假期能回家探望。记得从外地刚回来时，陪父亲去听戏，脑海中展现了儿时听戏的些许程序。 若是喜事，总是先来半个小时的歌曲串烧，继而一段较为经典的戏曲，然后一段小品，差不多已有九点多，最后几首老歌压轴，记忆中好像喜事总是唱一首难忘今宵，然后散场。赶上运气好的时候，有可能看上那么一两场杂技表演。 而丧事大多为了表达对死者以尊重，通常以一段唢呐开场。继而白头戏、小品、经典压轴歌曲父老乡亲。但，这次看戏，却让我大跌眼镜，又可以说是大开眼界，不知从何时起，一股低俗、毫无趣味之风气刮遍乡村。每逢‘当大事’时。再无以往的戏台，取而代之的是一辆农用五征车，将车厢打开，平铺，快捷方便。而再也不见三三两两等待化妆的演员。 唯有浓妆艳抹的所谓舞女。舞台的表现形式更从“多元化”趋向于“单一”。以前的所有项目，演技一毫无踪迹，而香艳的脱衣舞在舞台确实摄人心魄。时间安排更是极为巧尽。刚开始，用播放器先播放半小时的音乐，待酒足饭饱的人们珊珊而坐的时候，所谓‘少女’就要登台露肉了。一场持续两个小时的舞蹈占据了演出的所有，而大多数的结尾，也一般由此女穿内衣下台。 一个传播乡村文明的舞台到处充斥着糜烂的气息，演出未完，几经想走，但又有着强烈的好奇心，并不是对那厮的身体多么有兴趣，只是想知道，为了生活而牺牲一切，在台上极尽风光而台下满脸厌恶和疲倦的女人，到底会不会躲在自己心灵的角落，默默地哭泣。 所以我也懂了，有一万个人就会有一万个生活方式，各取所需。我们没权利去指责任何人，更没权利去劝导和改变她。作为茫茫众生的一菩提，沧海一粟，我想能做的仅仅是在心里暗暗叫几声可惜。真可惜啊。然后，悻悻的滚被窝，重拾旧梦。 谈到这两声可惜，我想说的是，虽然这个可惜有着对此女沦落的悲哀，为她选择这样一种生活方式而惋惜。但大多数还是对农村一种文化遗产渐渐遗失的痛楚。 读过余秋雨先生“文化苦旅”中有一篇是写废墟的。我想，农村文化正在由昌盛，繁荣趋向没落，几近毁灭。渐渐沦为农村文化的‘废墟’。但其却又有存在的意义与价值。对于文化的理解我始终太过于浅薄和粗鄙。或许这迎合了大多数人们的需求与需要，‘民心所向’。但当‘无知’的农民欣赏，玩乐过后，深深留在人们心坎中的沉痛思考，对于追随民族文化而言，恐怕又是一次巨大的心灵创伤吧。]]></content>
      <categories>
        <category>杂文</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
